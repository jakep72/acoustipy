{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quick Start","text":"<p>Investigate and optimize the acoustic performance of porous and microperforate materials with acoustipy.  Use the acoustic transfer matrix method to explore new material designs and identify unique properties of existing materials via inverse, indirect, and hybrid optimization schemes. </p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#create-and-activate-a-new-virtual-environment-recommended","title":"Create and activate a new virtual environment (recommended)","text":"<pre><code>mkdir &lt;your_env_name&gt;\npython -m venv .venv\ncd .venv\n(Windows) cd Scripts &amp;&amp; activate.bat\n(Linux) source bin/activate\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<pre><code>git clone https://github.com/jakep72/acoustipy.git\ncd acoustipy\npip install -e .\npip install -r requirements.txt\n</code></pre>"},{"location":"#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install acoustipy\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Examples of most of the functionality of acoustipy can be found in the Examples section.  The snippet below corresponds to the multilayer structure example and highlights a core feature of acoustipy -- the acoustic transfer matrix method. </p> <pre><code>from acoustipy import acousticTMM\n\n# Create an AcousticTMM object, specifying a diffuse sound field at 20C\nstructure = AcousticTMM(incidence='Diffuse',air_temperature=20)\n\n# Define the layers of the material using various models\nlayer1 = structure.Add_Resistive_Screen(thickness=1,flow_resistivity=100000,porosity=.86)\nlayer2 = structure.Add_DBM_Layer(thickness = 25.4,flow_resistivity=60000)\nlayer3 = structure.Add_Resistive_Screen(thickness = 1, flow_resistivity=500000,porosity=.75)\n\n# Specify the material backing condition -- in this case a 400mm air gap\nair = structure.Add_Air_Layer(thickness = 400)\n\n# Build the total transfer matrix of the structure + air gap\ntransfer_matrix = structure.assemble_structure(layer1,layer2,layer3,air)\n\n# Calculate the frequency dependent narrow band absorption coefficients\nabsorption = structure.absorption(transfer_matrix)\n\n# Calculate the 3rd octave bands absorption coefficients\nbands = structure.octave_bands(absorption)\n\n# Calculate the four frequency average absorption\nFFA = structure.FFA(bands)\n\n# Plot and display the narrow and 3rd band coefficients on the same figure\nstructure.plot_curve([absorption,bands],[\"absorption\",\"third octave\"])\n</code></pre> <p></p> <p></p> <p></p> <p>The example below demonstrates another core feature of acoustipy -- optimization routines that are able to identify the JCA model parameters of porous materials from impedance tube measurements.  The snippet can also be found under the Inverse Method in the Examples section. </p> <pre><code>from acoustipy import acousticTMM, AcousticID\n\n# Create an AcousticTMM object to generate toy impedance tube data\nstructure = acousticTMM(incidence='Normal',air_temperature = 20)\n\n# Define the JCA and air gap material parameters for the toy data\nlayer1 = structure.Add_JCA_Layer(thickness = 30, flow_resistivity = 46879, porosity = .93, tortuosity = 1.7, viscous_characteristic_length = 80, thermal_characteristic_length = 105)\nair = structure.Add_Air_Layer(thickness = 375)\n\n#Generate rigid backed absorption data and save to a csv file\ns1 = structure.assemble_structure(layer1)\nA1 = structure.absorption(s1)\nstructure.to_csv('no_gap',A1)\n\n# Generate air backed absorption data and save to a csv file\ns2 = structure.assemble_structure(layer1,air)\nA2 = structure.absorption(s2)\nstructure.to_csv('gap',A2)\n\n# Create an AcousticID object, specifying to mount types, data files, and data types\ninv = AcousticID(mount_type='Dual',no_gap_file=\"no_gap.csv\", gap_file = 'gap.csv',air_temperature=20,input_type='absorption')\n\n# Call the Inverse method to find the tortuosity, viscous, and thermal characteristic lengths of the material\nres = inv.Inverse(30, 47000,.926,air_gap=375,uncertainty=.2,verbose=True)\n\n# Display summary statistics about the optimization\nstats = inv.stats(res)\nprint(stats)\n\n# Plot the results of the found parameters compared to the toy input data\ninv.plot_comparison(res)\n\n# Save the optimization results to a csv\ninv.to_csv(\"params.csv\",res)\n\nstats = {'slope': 1.000037058594857, 'intercept': 9.276088883464206e-05, 'r_value': 0.9999999674493408, 'p_value': 0.0, 'std_err': 8.732362148426126e-06}\n</code></pre> <p></p> <p></p>"},{"location":"AcoustiBase/","title":"AcoustiBase","text":""},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase","title":"<code>AcoustiBase</code>","text":"<p>Create an AcoustiBase object</p>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase--description","title":"Description:","text":"<p>AcoustiBase provides a convenient way to save material parameters used within AcousticTMM or identified using AcousticID.  An SQLite database named 'acoustibase.db' is automatically created if the save_layer parameter from any of the 'Add_XXX_Layer' methods in AcousticTMM  is set to True. Likewise, if the 'to_database' method is called from AcousticID after an optimization routine, the results will be saved to the database.</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>class AcoustiBase():\n    '''\n    Create an AcoustiBase object\n\n    Description:\n    ------------\n    AcoustiBase provides a convenient way to save material parameters used within AcousticTMM or identified using AcousticID.  An SQLite database\n    named 'acoustibase.db' is automatically created if the save_layer parameter from any of the 'Add_XXX_Layer' methods in AcousticTMM  is set to True.\n    Likewise, if the 'to_database' method is called from AcousticID after an optimization routine, the results will be saved to the database.\n    '''\n\n    def __init__(self):\n\n        self.connection = sqlite3.connect(\"acoustibase.db\")\n\n        self.cur = self.connection.cursor()\n\n        self.cur.execute('''CREATE TABLE IF NOT EXISTS LAYER(id integer PRIMARY KEY, \n                                                            name TEXT NOT NULL UNIQUE,\n                                                            base_model text,\n                                                            biot_ef_model text,\n                                                            thickness float,\n                                                            flow resistivity float,\n                                                            porosity float,\n                                                            tortuosity float,\n                                                            viscous_characteristic_length float,\n                                                            thermal_characteristic_length float,\n                                                            thermal_permeability float,\n                                                            thermal_tortuosity float,\n                                                            viscous_tortuosity float,\n                                                            mass_density float,\n                                                            pore_diameter float,\n                                                            c_to_c_dist float,\n                                                            median_pore_size float,\n                                                            pore_size_distribution float)''')\n\n        self.cur.execute('''CREATE TABLE IF NOT EXISTS STRUCTURE(id integer PRIMARY KEY, \n                                                            structure_name TEXT NOT NULL UNIQUE,\n                                                            layer1 TEXT NOT NULL,\n                                                            layer2 text,\n                                                            layer3 text,\n                                                            layer4 text,\n                                                            layer5 text,\n                                                            layer6 text,\n                                                            layer7 text,\n                                                            layer8 text,\n                                                            layer9 text,\n                                                            layer10 text,\n                                                            layer11 text,\n                                                            layer12 text,\n                                                            layer13 text,\n                                                            layer14 text,\n                                                            layer15 text,\n                                                            layer16 text)''')\n\n\n\n    def close(self):\n        \"\"\"\n        Close the sqlite connection\n        \"\"\"\n        self.connection.close()\n\n    def execute(self,\n                new_data: list,\n                table: str):\n        \"\"\"\n        Insert a row of data into a table in the database\n\n        Parameters:\n        -----------\n\n        new_data (list):\n            data to insert into the table\n\n        table (str):\n            LAYER or STRUCTURE --&gt; table to insert data into\n        \"\"\"\n        try:\n            self.cur.execute(f'INSERT INTO {table} VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', new_data)\n        except sqlite3.IntegrityError:\n            raise ValueError(\"Layer name already exists in the database.  Please choose a unique name.\")\n\n    def commit(self):\n        \"\"\"\n        commit changes to the database\n        \"\"\"\n        self.connection.commit()\n\n    def pull(self,\n             table: str):\n        '''\n        retrieve all data from a specified table in the database\n\n        Parameters:\n        -----------\n\n        table (str):\n            LAYER or STRUCTURE --&gt; table to pull data from\n        '''\n        self.cur.execute(f'SELECT * from {table}')\n        rows = self.cur.fetchall()\n        return(rows)\n\n    def query(self,\n              SQL: str,\n              params: str):\n        '''\n        Query the database\n\n        Parameters:\n        -----------\n\n        SQL (str):\n            SQL query to perform to execute on the database\n\n        params (str):\n            General parameter to feed to the SQL statement\n        '''\n        self.cur.execute(SQL,params)\n        rows = self.cur.fetchall()\n        return(rows)\n\n    def summarize_layers(self):\n        '''\n        Write all information in the LAYER table of the database to a csv file\n        '''\n        self.cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n        tables = self.cur.fetchall()\n        data = self.pull(tables[0][0])\n\n        curs = self.cur\n        sql = \"select * from %s where 1=0;\" % tables[0][0]\n        curs.execute(sql)\n        header =  [d[0] for d in curs.description]\n\n        with open('layer_summary.csv','w',newline='') as out:\n            csv_out=csv.writer(out)\n            csv_out.writerow(header)\n            csv_out.writerows(data)\n\n    def summarize_structures(self):\n        '''\n        Write all information in the STRUCTURE table of the database to a csv file\n        '''\n        self.cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n        tables = self.cur.fetchall()\n        data = self.pull(tables[1][0])\n\n        curs = self.cur\n        sql = \"select * from %s where 1=0;\" % tables[1][0]\n        curs.execute(sql)\n        header =  [d[0] for d in curs.description]\n\n        with open('structure_summary.csv','w',newline='') as out:\n            csv_out=csv.writer(out)\n            csv_out.writerow(header)\n            csv_out.writerows(data)\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.close","title":"<code>close()</code>","text":"<p>Close the sqlite connection</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the sqlite connection\n    \"\"\"\n    self.connection.close()\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.execute","title":"<code>execute(new_data, table)</code>","text":"<p>Insert a row of data into a table in the database</p>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.execute--parameters","title":"Parameters:","text":"<p>new_data (list):     data to insert into the table</p> <p>table (str):     LAYER or STRUCTURE --&gt; table to insert data into</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def execute(self,\n            new_data: list,\n            table: str):\n    \"\"\"\n    Insert a row of data into a table in the database\n\n    Parameters:\n    -----------\n\n    new_data (list):\n        data to insert into the table\n\n    table (str):\n        LAYER or STRUCTURE --&gt; table to insert data into\n    \"\"\"\n    try:\n        self.cur.execute(f'INSERT INTO {table} VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', new_data)\n    except sqlite3.IntegrityError:\n        raise ValueError(\"Layer name already exists in the database.  Please choose a unique name.\")\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.commit","title":"<code>commit()</code>","text":"<p>commit changes to the database</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def commit(self):\n    \"\"\"\n    commit changes to the database\n    \"\"\"\n    self.connection.commit()\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.pull","title":"<code>pull(table)</code>","text":"<p>retrieve all data from a specified table in the database</p>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.pull--parameters","title":"Parameters:","text":"<p>table (str):     LAYER or STRUCTURE --&gt; table to pull data from</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def pull(self,\n         table: str):\n    '''\n    retrieve all data from a specified table in the database\n\n    Parameters:\n    -----------\n\n    table (str):\n        LAYER or STRUCTURE --&gt; table to pull data from\n    '''\n    self.cur.execute(f'SELECT * from {table}')\n    rows = self.cur.fetchall()\n    return(rows)\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.query","title":"<code>query(SQL, params)</code>","text":"<p>Query the database</p>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.query--parameters","title":"Parameters:","text":"<p>SQL (str):     SQL query to perform to execute on the database</p> <p>params (str):     General parameter to feed to the SQL statement</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def query(self,\n          SQL: str,\n          params: str):\n    '''\n    Query the database\n\n    Parameters:\n    -----------\n\n    SQL (str):\n        SQL query to perform to execute on the database\n\n    params (str):\n        General parameter to feed to the SQL statement\n    '''\n    self.cur.execute(SQL,params)\n    rows = self.cur.fetchall()\n    return(rows)\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.summarize_layers","title":"<code>summarize_layers()</code>","text":"<p>Write all information in the LAYER table of the database to a csv file</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def summarize_layers(self):\n    '''\n    Write all information in the LAYER table of the database to a csv file\n    '''\n    self.cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tables = self.cur.fetchall()\n    data = self.pull(tables[0][0])\n\n    curs = self.cur\n    sql = \"select * from %s where 1=0;\" % tables[0][0]\n    curs.execute(sql)\n    header =  [d[0] for d in curs.description]\n\n    with open('layer_summary.csv','w',newline='') as out:\n        csv_out=csv.writer(out)\n        csv_out.writerow(header)\n        csv_out.writerows(data)\n</code></pre>"},{"location":"AcoustiBase/#src.acoustipy.Database.AcoustiBase.summarize_structures","title":"<code>summarize_structures()</code>","text":"<p>Write all information in the STRUCTURE table of the database to a csv file</p> Source code in <code>src/acoustipy/Database.py</code> <pre><code>def summarize_structures(self):\n    '''\n    Write all information in the STRUCTURE table of the database to a csv file\n    '''\n    self.cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tables = self.cur.fetchall()\n    data = self.pull(tables[1][0])\n\n    curs = self.cur\n    sql = \"select * from %s where 1=0;\" % tables[1][0]\n    curs.execute(sql)\n    header =  [d[0] for d in curs.description]\n\n    with open('structure_summary.csv','w',newline='') as out:\n        csv_out=csv.writer(out)\n        csv_out.writerow(header)\n        csv_out.writerows(data)\n</code></pre>"},{"location":"AcousticID/","title":"AcousticID","text":""},{"location":"AcousticID/#src.acoustipy.Params.AcousticID","title":"<code>AcousticID</code>","text":"<p>Create a AcousticID object</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID--description","title":"Description:","text":"<p>AcousticID is an optimization routine built on top of SciPy (https://scipy.org/) and AcousticTMM that can be used  to identify the difficult-to-measure parameters of the Johnson-Chompoux-Allard equivalent fluid model using an  inverse characterization procedure based on the following paper: </p> <p>Atalla, Youssef &amp; Panneton, R.. (2005). Inverse acoustical characterization of open cell porous  media using impedance tube measurements. Canadian Acoustics - Acoustique Canadienne. 33.</p> <p>Or by using an indirect characterization procedure based on the following paper:</p> <p>Panneton, R. &amp; Salissou, Yacoubou. (2009). Indirect acoustical characterization of sound absorbing materials..  The Journal of the Acoustical Society of America. 126. 2297. 10.1121/1.3249416.</p> <p>Or by a hybrid characterization procedure that combines the inverse and indirect methods.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID--attributes","title":"Attributes","text":"<p>mount_type (str):     'No Gap', 'Gap', or 'Dual'       Specify whether impedance tube measurements are of a sample with rigid backing, an air gap, or both.</p> <p>no_gap_file (str):     Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance     coefficients of a single porous layer obtained from an impedence tube measurement with rigid backing.     The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and coefficients in the 2nd.</p> <p>gap_file (str):     Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance     coefficients of a single porous layer obtained from an impedence tube measurement with an air gap backing.     The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and coefficients in the 2nd.</p> <p>input_type (str):     'absorption', 'reflection', or 'surface' -- specifies the type of measurement made with the impedance tube.</p> <p>air_temperature (float):     Temperature of air [\u00b0C].  If specified, all other air properties will be determined by this parameter.</p> <p>sound_speed (float):     Speed of sound in air [m/s]</p> <p>air_density (float):     Density of air [kg/m3]</p> <p>Cp (float):     Specific heat @ constant pressure [kJ/kg K]</p> <p>Cv (float):     Specifc heat @ constant volume [kJ/kg K]</p> <p>viscosity (float):     Dynamic viscosity of air [kg/m*s]</p> <p>Pr (float):     Prandtl number of air []</p> <p>P0 (float):     Atmospheric pressure [Pa]</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>class AcousticID():\n    \"\"\"\n    Create a AcousticID object\n\n    Description:\n    ------------\n    AcousticID is an optimization routine built on top of SciPy (https://scipy.org/) and AcousticTMM that can be used \n    to identify the difficult-to-measure parameters of the Johnson-Chompoux-Allard equivalent fluid model using an \n    inverse characterization procedure based on the following paper: \n\n    Atalla, Youssef &amp; Panneton, R.. (2005). Inverse acoustical characterization of open cell porous \n    media using impedance tube measurements. Canadian Acoustics - Acoustique Canadienne. 33.\n\n    Or by using an indirect characterization procedure based on the following paper:\n\n    Panneton, R. &amp; Salissou, Yacoubou. (2009). Indirect acoustical characterization of sound absorbing materials.. \n    The Journal of the Acoustical Society of America. 126. 2297. 10.1121/1.3249416.\n\n    Or by a hybrid characterization procedure that combines the inverse and indirect methods.\n\n    Attributes\n    ----------\n    mount_type (str):\n        'No Gap', 'Gap', or 'Dual'    \n        Specify whether impedance tube measurements are of a sample with rigid backing, an air gap, or both.\n\n    no_gap_file (str):\n        Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance\n        coefficients of a single porous layer obtained from an impedence tube measurement with rigid backing.\n        The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and coefficients in the 2nd.\n\n    gap_file (str):\n        Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance\n        coefficients of a single porous layer obtained from an impedence tube measurement with an air gap backing.\n        The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and coefficients in the 2nd.\n\n    input_type (str):\n        'absorption', 'reflection', or 'surface' -- specifies the type of measurement made with the impedance tube.\n\n    air_temperature (float):\n        Temperature of air [\u00b0C].  If specified, all other air properties will be determined by this parameter.\n\n    sound_speed (float):\n        Speed of sound in air [m/s]\n\n    air_density (float):\n        Density of air [kg/m3]\n\n    Cp (float):\n        Specific heat @ constant pressure [kJ/kg K]\n\n    Cv (float):\n        Specifc heat @ constant volume [kJ/kg K]\n\n    viscosity (float):\n        Dynamic viscosity of air [kg/m*s]\n\n    Pr (float):\n        Prandtl number of air []\n\n    P0 (float):\n        Atmospheric pressure [Pa]\n\n    \"\"\"\n    def __init__(self,\n                 mount_type:str = \"No Gap\",\n                 no_gap_file:str = None,\n                 gap_file:str = None,\n                 input_type:str = 'absorption',\n                 air_temperature:float = None,\n                 sound_speed:float = 343.152,\n                 air_density:float = 1.2058,\n                 Cp:float = 1.004425,\n                 Cv:float = 0.717425,\n                 viscosity:float = 1.825e-05,\n                 Pr:float = .7157,\n                 P0:float = 101325\n                 ):\n\n        self.temp = air_temperature\n        self.speed = sound_speed\n        self.density = air_density\n        self.Cp = Cp\n        self.Cv = Cv\n        self.viscosity = viscosity\n        self.Pr = Pr\n        self.P0 = P0\n        self.opt_type = mount_type\n        self.input_type = input_type\n        self.thickness = None\n        self.flow_resistivity = None\n        self.porosity = None\n        self.uncertainty = None\n        self.air_gap = None\n\n\n\n        if self.opt_type == 'No Gap':\n            if self.input_type == 'reflection':\n                self.no_gap_data = self.load_to_array(no_gap_file)\n\n            elif self.input_type == 'surface':\n                self.no_gap_data = self.load_to_array(no_gap_file)\n\n            elif self.input_type == 'absorption':\n                    self.no_gap_data = self.load_to_array(no_gap_file,type='float')\n\n        elif self.opt_type == 'Gap':\n            if self.input_type == 'reflection':    \n                self.gap_data = self.load_to_array(gap_file)\n\n            elif self.input_type == 'surface':\n                self.gap_data = self.load_to_array(gap_file)\n\n            elif self.input_type == 'absorption':\n                    self.gap_data = self.load_to_array(gap_file,type='float')\n\n        elif self.opt_type == 'Dual':\n            if self.input_type == 'reflection':\n                self.no_gap_data = self.load_to_array(no_gap_file)\n                self.gap_data = self.load_to_array(gap_file)\n\n            elif self.input_type == 'surface':\n                self.no_gap_data = self.load_to_array(no_gap_file)\n                self.gap_data = self.load_to_array(gap_file)\n\n\n            elif self.input_type == 'absorption':\n                self.no_gap_data = self.load_to_array(no_gap_file,type='float')\n                self.gap_data = self.load_to_array(gap_file,type='float')\n\n    @property\n    def frequency(self):\n        #frequency range of interest\n\n        if self.opt_type == 'No Gap':\n            no_gap_freq = self.no_gap_data[:,0]\n            return(no_gap_freq)\n\n        elif self.opt_type == 'Gap':\n            gap_freq = self.gap_data[:,0]\n            return(gap_freq)\n\n        elif self.opt_type == 'Dual':\n            no_gap_freq = self.no_gap_data[:,0]\n            gap_freq = self.gap_data[:,0]\n\n            if np.array_equal(no_gap_freq,gap_freq) != True:\n                raise ValueError(\"Frequencies must match between no gap and gap absorption curves\")\n            else:\n                return(no_gap_freq)\n\n\n    @property\n    def meas_abs(self):\n        #measured absorption coefficients\n        if self.input_type == 'absorption':\n            if self.opt_type == 'No Gap':\n                no_gap_abs = self.no_gap_data[:,1]\n                return([no_gap_abs,None])\n\n            elif self.opt_type == 'Gap':\n                gap_abs = self.gap_data[:,1]\n                return([None,gap_abs])\n\n            elif self.opt_type == 'Dual':\n                no_gap_abs = self.no_gap_data[:,1]\n                gap_abs = self.gap_data[:,1]\n                return([no_gap_abs,gap_abs])\n\n        elif self.input_type == 'reflection':\n            if self.opt_type == 'No Gap':\n                no_gap_abs = 1-abs(self.no_gap_data[:,1])**2\n                return([no_gap_abs,None])\n\n            elif self.opt_type == 'Gap':\n                gap_abs = 1-abs(self.gap_data[:,1])**2\n                return([None,gap_abs])\n\n            elif self.opt_type == 'Dual':\n                no_gap_abs = 1-abs(self.no_gap_data[:,1])**2\n                gap_abs = 1-abs(self.gap_data[:,1])**2\n                return([no_gap_abs,gap_abs])\n\n        elif self.input_type == 'surface':\n            if self.opt_type == 'No Gap':\n                ngzs = self.no_gap_data\n                ngr = (ngzs-self.Z0)/(ngzs+self.Z0)\n                no_gap_abs = 1-abs(ngr[:,1])**2\n                return([no_gap_abs,None])\n\n            elif self.opt_type == 'Gap':\n                gzs = self.gap_data\n                gr = (gzs-self.Z0)/(gzs+self.Z0)\n                gap_abs = 1-abs(gr[:,1])**2\n                return([None,gap_abs])\n\n            elif self.opt_type == 'Dual':\n                ngzs = self.no_gap_data\n                ngr = (ngzs-self.Z0)/(ngzs+self.Z0)\n                no_gap_abs = 1-abs(ngr[:,1])**2\n\n                gzs = self.gap_data\n                gr = (gzs-self.Z0)/(gzs+self.Z0)\n                gap_abs = 1-abs(gr[:,1])**2\n                return([no_gap_abs,gap_abs])\n\n    @property    \n    def density_temp(self):\n        #Temperature dependent density of air\n        if self.temp is None:\n            airdensity = self.density\n        else:\n            airdensity = ((1.07743*1e-5)*(self.temp**2))+((-0.004581339)*self.temp)+(1.294685259)\n        return (airdensity)\n\n    @property\n    def soundspeed_temp(self):\n        #Temperature dependent speed of sound in air\n        if self.temp is None:\n            soundspeed = self.speed\n        else:\n            soundspeed = (.6016*self.temp)+331.12\n        return(soundspeed)\n\n    @property\n    def gamma_temp(self):\n        #Temperature dependent specific heat ratio\n        if self.temp is None:\n            gamma = self.Cp/self.Cv\n        else:\n            Cp = (4.00166852057851e-07*self.temp**2)+(1.69769187986639e-05*self.temp)+(1.00559293937709)\n            Cv = (3.65205412117683e-07*self.temp**2)+(2.88811127246258e-05*self.temp)+(7.17032243570935e-01)\n            gamma = Cp/Cv\n        return(gamma)\n\n    @property\n    def Cp_temp(self):\n        #Temperature dependent specific heat ratio\n        if self.temp is None:\n            Cp = self.Cp\n        else:\n            Cp = (4.00166852057851e-07*self.temp**2)+(1.69769187986639e-05*self.temp)+(1.00559293937709)\n\n        return(Cp)\n\n    @property\n    def Cv_temp(self):\n        #Temperature dependent specific heat ratio\n        if self.temp is None:\n            Cv = self.Cv\n        else:\n            Cv = (3.65205412117683e-07*self.temp**2)+(2.88811127246258e-05*self.temp)+(7.17032243570935e-01)\n\n        return(Cv)\n\n    @property\n    def viscosity_temp(self):\n        #Temperature dependent viscosity of air\n        if self.temp is None:\n            visc = self.viscosity\n            return(visc)\n        else:\n            visc = (-3.52159145081837e-11*self.temp**2)+(4.93272149610679e-8*self.temp)+(1.72293415521214e-5)\n            return(visc)\n\n    @property\n    def Pr_temp(self):\n        #Temperature dependent prandtl number\n        if self.temp is None:\n            Prandtl = self.Pr\n        else:\n            Prandtl = (7.06471476243448e-07*self.temp**2)+(-2.20826446051168e-04*self.temp)+(0.71980868)\n        return(Prandtl)\n\n    @property\n    def Z0(self):\n        #Characteristic Impedance of Air\n        z0 = self.density_temp*self.soundspeed_temp\n        return(z0)\n\n    def _predictionJCA(self,\n                       parameters: dict) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the predicted frequency dependent absorption curve using the parameters identified in the\n        optimization procedure defined in the find_values methods\n\n        Parameters\n        ----------\n        parameters (dict):\n            dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n            viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n        Returns\n        -------\n        predicted (ndarray):\n            2D array of frequencies and predicted absorption coefficients \n\n        \"\"\"\n\n        dummy_struct = AcousticTMM(air_temperature=self.temp,\n                                   sound_speed=self.soundspeed_temp,\n                                   air_density=self.density_temp,\n                                   Cp=self.Cp,\n                                   Cv=self.Cv,\n                                   viscosity=self.viscosity_temp,\n                                   Pr=self.Pr_temp,\n                                   P0=self.P0)\n\n        t = parameters['thickness']\n        fr = parameters['flow resistivity']\n        phi = parameters['porosity']\n        tort = parameters['tortuosity']\n        vcl = parameters['viscous characteristic length']\n        tcl = parameters['thermal characteristic length']\n        air_gap = parameters['air gap']\n\n        layer = dummy_struct.Add_JCA_Layer(t,fr,phi,tort,vcl,tcl)\n        air = dummy_struct.Add_Air_Layer(thickness = air_gap)\n        dummy_struct.frequency = self.frequency\n\n        if self.opt_type == 'Gap' or self.opt_type == 'No Gap':\n            s = dummy_struct.assemble_structure(layer,air)\n            predicted = dummy_struct.absorption(s)[:,1]\n            return(predicted)\n\n        elif self.opt_type == 'Dual':\n            no_gap_s = dummy_struct.assemble_structure(layer)\n            gap_s = dummy_struct.assemble_structure(layer,air)\n\n            no_gap_pred = dummy_struct.absorption(no_gap_s)[:,1]\n            gap_pred = dummy_struct.absorption(gap_s)[:,1]\n\n            return([no_gap_pred,gap_pred])\n\n    def _error(self,\n               x: list) -&gt; float:\n        \"\"\"\n        Function that is minimized in the optimization routine. Calculates the error between the measured (impedance tube)\n        and predicted (TMM) absorption coefficients.\n\n        Parameters\n        ----------\n        x (list):\n            list structure containing the identified thickness, flow resistivity, porosity, tortuosity, viscous characteristic length,\n            thermal characteristic length, and air gap thickness of the sample (in that order).\n\n        Returns\n        -------\n        err (float):\n            if opt_type is 'No Gap' or 'Gap' --&gt; sum of the absolute square difference between measured and predicted absorption coefficients across all specified frequencies.\n            if opt_type is 'Dual', the error for each mounting condition is averaged into a single error metric\n\n        \"\"\"\n\n        t = x[0]\n        fr = x[1]\n        phi = x[2]\n        tort = x[3]\n        vcl = x[4]\n        tcl = x[5]\n        air = x[6]\n\n        params = {'thickness':t,'flow resistivity':fr,'porosity':phi,'tortuosity':tort,'viscous characteristic length':vcl,'thermal characteristic length':tcl,'air gap':air}\n\n        A = self._predictionJCA(params)\n\n        if self.opt_type == 'No Gap':\n            err = np.sum(np.abs(np.diff(A-self.meas_abs[0]))**2)\n            return(err)\n\n        elif self.opt_type == 'Gap':\n            err = np.sum(np.abs(np.diff(A-self.meas_abs[1]))**2)\n            return(err)\n\n        elif self.opt_type == 'Dual':\n            err = (np.sum(np.abs(np.diff(A[0]-self.meas_abs[0]))**2)+np.sum(np.abs(np.diff(A[1]-self.meas_abs[1]))**2))/2\n            return(err)\n\n    def _bounds(self,\n                tort: float) -&gt; tuple:\n        \"\"\"\n        Defines the lower and upper boundary values for the parameters in the optimization routine. Bounds for thickness, flow resistivity,\n        porosity, and air gap are calculated using the supplied \"known\" values and the uncertainty.  Tortuosity, viscous, and thermal characteristic\n        length bounds are defined in:\n\n        Atalla, Youssef &amp; Panneton, R.. (2005). Inverse acoustical characterization of open cell porous \n        media using impedance tube measurements. Canadian Acoustics - Acoustique Canadienne. 33.\n\n        Parameters\n        ----------\n        tort (float):\n            tortuosity --&gt; defined either as the initial guess or the most recent value returned by the optimization routine.\n\n        Returns\n        -------\n        bounds (tuple):\n            contains tuples of the lower and upper bounds for each parameter.\n\n        \"\"\"\n\n        l_unc = 1-self.uncertainty\n        u_unc = 1+self.uncertainty\n\n        t_lb = l_unc*self.thickness\n        t_ub = u_unc*self.thickness\n\n\n        fr_lb = l_unc*self.flow_resistivity\n        fr_ub = u_unc*self.flow_resistivity\n\n        phi_lb = l_unc*self.porosity\n        phi_ub = u_unc*self.porosity\n\n        air_lb = l_unc*self.air_gap\n        air_ub = u_unc*self.air_gap\n\n        tort_lb = 1\n        tort_ub = 4\n\n        vcl_lb = ((1/3.3)*np.sqrt((8*tort*self.viscosity_temp)/(self.flow_resistivity*self.porosity)))/(1e-6)\n        vcl_ub =((1/.3)*np.sqrt((8*tort*self.viscosity_temp)/(self.flow_resistivity*self.porosity)))/(1e-6)\n\n        tcl_lb = vcl_lb\n        tcl_ub = vcl_ub\n\n        tort_b = (tort_lb,tort_ub)\n        vcl_b = (vcl_lb,vcl_ub)\n        tcl_b = (tcl_lb,tcl_ub)\n        phi_b = (phi_lb,phi_ub)\n        fr_b = (fr_lb,fr_ub)\n        t_b = (t_lb,t_ub)\n        air_b = (air_lb,air_ub)\n\n        bounds = (t_b,fr_b,phi_b,tort_b,vcl_b,tcl_b,air_b)\n\n        return (bounds)\n\n    def Inverse(self,\n                thickness: float,\n                flow_resistivity: float,\n                porosity: float,\n                air_gap: float=0,\n                uncertainty: float=0.01,\n                early_stopping: float=1e-15,\n                verbose: bool=False) -&gt; dict:\n        \"\"\"\n        Optimization routine for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths).\n        The routine uses the Sequential Least Squares Programming method (https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html)\n        to minimize the error between predicted and actual absorption coefficients.\n\n        If the early stopping criterion is not met after an initial guess, a unique grid search of the parameter space is crafted to help ensure\n        the global minimum is found (ie the correct values for the parameters are identified).\n\n        Parameters\n        ----------\n        thickness (float):\n            The measured thickness of the sample [mm]\n\n        flow_resistivity (float):\n            The measured flow resistivity of the sample [Pa*s/m2]\n\n        porosity (float):\n            The measured porosity of the sample [-]\n\n        air_gap (float):\n            The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n        uncertainty (float):\n            A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements\n            of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.\n\n        early_stopping (float):\n            criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate\n            and return the results. The default value of 1e-15 has been tested on a number of simulated cases.\n\n        verbose (bool):\n             If true, the progress of the optimization routine will print to the console.\n\n        Returns\n        -------\n        result_dict (dict):\n            dictionary containing the identified parameters associated with the lowest calculated error.\n\n        \"\"\"\n        self.thickness = thickness\n        self.flow_resistivity = flow_resistivity\n        self.porosity = porosity\n        self.air_gap = air_gap\n\n        if uncertainty &gt;= 0 and uncertainty &lt;= 1:\n            self.uncertainty = uncertainty\n\n        else:\n            print(\"Uncertainty must be between 0 and 1, reverting to default uncertainty of 1.0%!\")\n            self.uncertainty = 0.01\n\n        init_tort = 2.5\n\n        bnds = self._bounds(init_tort)\n        x0 = [self.thickness,self.flow_resistivity,self.porosity,init_tort,(bnds[4][1]-bnds[4][0])/2,(bnds[5][1]-bnds[5][0])/2,self.air_gap] \n        cons = ({'type':'ineq','fun':lambda x:x[5]-x[4]})\n        res = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n        err = res.fun\n        results = np.around(res.x,decimals=3)\n\n        if err &lt; early_stopping:\n            result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}  \n            if verbose == True:\n                print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n            return(result_dict)\n\n        elif err &gt; early_stopping:\n            bnds_temp = self._bounds(results[3])\n            tort_grid = [bnds_temp[3][0],(.75*bnds_temp[3][0]+.25*bnds_temp[3][1]),(.5*bnds_temp[3][0]+.5*bnds_temp[3][1]),(.25*bnds_temp[3][0]+.75*bnds_temp[3][1]),bnds_temp[3][1]]\n            vcl_grid = [bnds_temp[4][0],(.75*bnds_temp[4][0]+.25*bnds_temp[4][1]),(.5*bnds_temp[4][0]+.5*bnds_temp[4][1]),(.25*bnds_temp[4][0]+.75*bnds_temp[4][1]),bnds_temp[4][1]]\n            tcl_grid = [bnds_temp[5][0],(.75*bnds_temp[5][0]+.25*bnds_temp[5][1]),(.5*bnds_temp[5][0]+.5*bnds_temp[5][1]),(.25*bnds_temp[5][0]+.75*bnds_temp[5][1]),bnds_temp[5][1]]\n\n            loop_len = len(tort_grid)*len(vcl_grid)*len(tcl_grid)\n            i = 1\n\n            for to in tort_grid: \n                for v in vcl_grid:\n                    for tc in tcl_grid:\n                        phi = self.porosity\n                        fr = self.flow_resistivity\n                        t = self.thickness\n                        air = self.air_gap\n                        x0 = [t,fr,phi,to,v,tc,air]\n\n                        grid_search = round((i/loop_len)*100,2)\n                        bnds = self._bounds(results[3])\n                        res2 = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n\n                        if verbose == True:\n                            print(f\"{grid_search}% of the parameter space has been searched. The current lowest error is: {err}\")\n\n\n                        if res2.fun &lt; err:\n                            err = res2.fun\n                            results = np.around(res2.x,decimals=3)\n\n                            if err &lt; early_stopping:\n                                result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}\n                                if verbose == True:\n                                    print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n                                return(result_dict)\n                        i+=1\n\n\n            print(\"Warning: stopping criterion not met during parameter search. Double check known inputs and/or consider increasing the uncertainty value of the knowns.\")\n            result_dict = {'thickness': results[0],\n                           'flow resistivity': results[1],\n                           'porosity': results[2],\n                           'tortuosity': results[3],\n                           'viscous characteristic length': results[4],\n                           'thermal characteristic length': results[5],\n                           'air gap': results[6],\n                           'error': err}\n\n            return(result_dict)\n\n    def Indirect(self,\n                 thickness: float,\n                 porosity: float,\n                 flow_resistivity: float=None,\n                 air_gap: float=0) -&gt; dict:\n        \"\"\"\n        Indirect method for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths), based on:\n\n        Panneton, R. &amp; Salissou, Yacoubou. (2009). Indirect acoustical characterization of sound absorbing materials.. \n        The Journal of the Acoustical Society of America. 126. 2297. 10.1121/1.3249416.\n\n        This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples and \n        it is susceptible to uncertainty in the measurements of thickness, porosity, flow resistivity, air gap, \n        and the acoustic indicator(s) -- but the advantage is that it does not require a flow resistivity measurement in order to \n        estimate the JCA parameters.\n\n        Parameters\n        ----------\n        thickness (float):\n            The measured thickness of the sample [mm]\n\n        porosity (float):\n            The measured porosity of the sample [-]\n\n        flow_resistivity (float):\n            Optional, the measured flow resistivity of the sample [Pa*s/m2].  If no flow resistivity is specified, the value\n            will be estimated automatically.\n\n        air_gap (float):\n            The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n        Returns\n        -------\n        result_dict (dict):\n            dictionary containing the identified parameters associated with the lowest calculated error.\n\n        \"\"\"\n\n        self.thickness = thickness\n        self.porosity = porosity\n        self.air_gap = air_gap\n\n        if flow_resistivity == None:\n            self.flow_resistivity = None\n            return_preds = True\n        else:\n            self.flow_resistivity = flow_resistivity\n            return_preds = False\n\n        air_gap = self.air_gap/1000\n        thickness = self.thickness/1000\n        w = 2*np.pi*self.frequency\n        k0 = w / self.soundspeed_temp\n\n        if self.input_type == 'absorption':\n            raise ValueError('Absorption data cannot be used for Indirect characterizations, please specify reflection or surface impedance data')\n\n        elif self.opt_type == 'Gap' or self.opt_type == 'No Gap':\n            raise ValueError('Dual mount types are required for Indirect characterizations')\n\n        elif self.input_type == 'surface':\n            Zs_NG = self.no_gap_data[:,1]\n            Zs_G = self.gap_data[:,1]\n\n        elif self.input_type == 'reflection':\n            Zs_NG = self.Z0*((1+self.no_gap_data[:,1])/(1-self.no_gap_data[:,1]))\n            Zs_G = self.Z0*((1+self.gap_data[:,1])/(1-self.gap_data[:,1]))\n\n\n        T11A = np.cos(k0*air_gap)\n        T21A = (1j/self.Z0)*np.sin(k0*air_gap)\n        Zs_A = T11A/T21A\n\n        Zp = np.sqrt((Zs_NG*(Zs_G-Zs_A))+(Zs_G*Zs_A))\n        kp = np.arctan(Zp/(1j*Zs_NG))/thickness\n\n        test = np.column_stack((self.frequency,np.real(Zp/(1j*Zs_NG))))\n\n        try:\n            cutoff = test[np.where(test[:-1] * test[1:] &lt; 0 )[0]]\n            cutoff = np.abs(np.min(cutoff[:,0]))\n        except ValueError:\n            cutoff = np.max(self.frequency)\n\n        peff = Zp*kp/w\n        keff = w*np.divide(Zp,kp)\n\n        re_peff = np.real(peff)\n        im_peff = np.imag(peff)\n\n        fr = np.column_stack((self.frequency**2,-im_peff*w))\n        fr_curve = fr[np.where(fr[:,0] &lt;= cutoff**2)]\n        slope1,intercept1,r_value1,p_value1,std_err1 = scipy.stats.linregress(fr_curve[:,0],fr_curve[:,1])\n\n        jca_fr = np.abs(intercept1)\n\n        #######################################################################################################\n\n        if return_preds == False:\n            tort = (self.porosity/self.density_temp)*(re_peff-np.sqrt((im_peff**2)-((self.flow_resistivity/w)**2)))\n        elif return_preds == True:\n            tort = (self.porosity/self.density_temp)*(re_peff-np.sqrt((im_peff**2)-((jca_fr/w)**2)))\n        tort1 = np.column_stack((self.frequency,tort))\n        tort_curve = tort1[np.where(tort1[:,0] &lt;= cutoff )]\n        jca_tort = np.abs(np.mean(tort_curve[:,1]))\n\n        #######################################################################################################\n\n        phi_num = (self.density_temp*jca_tort)\n        if return_preds == False:\n            phi_denom = re_peff-np.sqrt((im_peff**2)-((self.flow_resistivity/w)**2))\n        elif return_preds == True:\n            phi_denom = re_peff-np.sqrt((im_peff**2)-((jca_fr/w)**2))\n        phi = phi_num/phi_denom\n        phi1 = np.column_stack((self.frequency,phi))\n        phi_curve = phi1[np.where((phi1[:,0] &lt;= cutoff) &amp; (phi1[:,0] &gt;= 500))]\n        jca_phi = np.abs(np.mean(phi_curve[:,1]))\n\n        ####################################################################################################### \n\n        if return_preds == False:\n            vcl = jca_tort*np.sqrt((2*self.density_temp*self.viscosity_temp)/((w*self.porosity*im_peff)*((self.density_temp*jca_tort)-(self.porosity*re_peff))))/(1e-6)\n        elif return_preds == True:\n            vcl = jca_tort*np.sqrt((2*self.density_temp*self.viscosity_temp)/((w*jca_phi*im_peff)*((self.density_temp*jca_tort)-(jca_phi*re_peff))))/(1e-6)\n        vcl1 = np.column_stack((self.frequency,vcl))\n        vcl_curve = vcl1[np.where(vcl1[:,0] &lt;= cutoff )]\n        jca_vcl = np.abs(np.mean(vcl_curve[:,1]))\n\n        #######################################################################################################        \n\n        tcl0 = np.sqrt((2*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp))\n        if return_preds == False:\n            tcl1 = ((1-((keff*self.porosity)/(self.gamma_temp*self.P0)))/(1-((keff*self.porosity)/self.P0)))**2\n        elif return_preds == True:\n            tcl1 = ((1-((keff*jca_phi)/(self.gamma_temp*self.P0)))/(1-((keff*jca_phi)/self.P0)))**2\n        tcl2 = 1/(-np.imag(tcl1))\n        tcl3 = np.sqrt(2*tcl2)       \n        tcl4 = tcl0*tcl3/(1e-6)\n        tcl5 = np.column_stack((self.frequency,tcl4))\n        tcl_curve = tcl5[np.where((tcl5[:,0] &lt;= cutoff) &amp; (tcl5[:,0] &gt;= 500))]\n        jca_tcl = np.abs(np.mean(tcl_curve[:,1]))\n\n        #######################################################################################################           \n\n        if return_preds == False:\n            kn0 = (self.porosity*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp)\n        elif return_preds == True:\n            kn0 = (jca_phi*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp)\n        kn1 = 1/np.sqrt(-np.real(tcl1))\n        kn3 = kn0*kn1/(1e-10)\n        kn4 = np.column_stack((self.frequency,kn3))\n        k0_curve = kn4[np.where((kn4[:,0] &lt;= cutoff) &amp; (kn4[:,0] &gt;= 500))]\n        jca_k0 = np.abs(np.mean(k0_curve[:,1]))\n\n        result_dict = {'thickness': self.thickness,\n                       'flow resistivity': self.flow_resistivity,\n                       'porosity': self.porosity,\n                       'tortuosity': round(jca_tort,4),\n                        'viscous characteristic length': round(jca_vcl,4),\n                        'thermal characteristic length': round(jca_tcl,4),\n                        'air gap': self.air_gap} \n\n        full_predicted_dict = {'thickness': self.thickness,\n                               'flow resistivity': jca_fr,\n                               'porosity': jca_phi,\n                               'tortuosity': jca_tort,\n                               'viscous characteristic length': jca_vcl,\n                               'thermal characteristic length': jca_tcl,\n                               'air gap': self.air_gap} \n\n        if return_preds == False:\n            return(result_dict)\n\n        elif return_preds == True:\n            return(full_predicted_dict)\n\n\n    def Hybrid(self,\n               thickness: float,\n               porosity: float,\n               flow_resistivity: float=None,\n               air_gap: float=0,\n               uncertainty: float=0.01,\n               early_stopping: float=1e-15,\n               verbose: bool=False) -&gt; dict:\n        \"\"\"\n        The Hybrid routine uses both the inverse and indirect characterization methods to identify the JCA parameters.  The parameters are \n        first estimated using the indirect method and the error between measured and estimated absorption coefficients is determined.\n\n        If the early stopping criterion is not met using the indirect method, the estimate is then used as the initial guess for the inverse\n        procedure and to calculate the bounds of the grid search.\n\n        This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples.\n        The advantage of using this procedure compared to the inverse or indirect methods alone are:\n            Inverse: The Hybrid method does not require flow resitivity to be known.\n            Indirect:  The Hybrid method is much less susceptible to uncertainty in the measurements.\n\n        Parameters\n        ----------\n        thickness (float):\n            The measured thickness of the sample [mm]\n\n        flow_resistivity (float):\n            The measured flow resistivity of the sample [Pa*s/m2]\n\n        porosity (float):\n            The measured porosity of the sample [-]\n\n        air_gap (float):\n            The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n        uncertainty (float):\n            A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements\n            of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.\n\n        early_stopping (float):\n            criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate\n            and return the results. The default value of 1e-15 has been tested on a number of simulated cases.\n\n        verbose (bool):\n             If true, the progress of the optimization routine will print to the console.\n\n        Returns\n        -------\n        result_dict (dict):\n            dictionary containing the identified parameters associated with the lowest calculated error.\n\n        \"\"\"\n        self.thickness = thickness\n        self.porosity = porosity\n        self.air_gap = air_gap\n        if uncertainty &gt;= 0 and uncertainty &lt;= 1:\n            self.uncertainty = uncertainty\n\n        else:\n            print(\"Uncertainty must be between 0 and 1, reverting to default uncertainty of 1.0%!\")\n            self.uncertainty = 0.01\n\n\n        indirect_results = self.Indirect(self.thickness,self.porosity,flow_resistivity,self.air_gap)\n\n        if np.isnan(indirect_results['thermal characteristic length']):\n            indirect_results['thermal characteristic length'] = indirect_results['viscous characteristic length']\n\n        self.flow_resistivity = indirect_results['flow resistivity']\n\n        init_tort = indirect_results['tortuosity']\n\n        bnds = self._bounds(init_tort)\n        x0 = [self.thickness,indirect_results['flow resistivity'],indirect_results['porosity'],init_tort,indirect_results['viscous characteristic length'],indirect_results['thermal characteristic length'],self.air_gap] \n        cons = ({'type':'ineq','fun':lambda x:x[5]-x[4]})\n        res = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n        err = res.fun\n        results = np.around(res.x,decimals=3)\n\n        if err &lt; early_stopping:\n            result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}  \n            if verbose == True:\n                print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n            return(result_dict)\n\n        elif err &gt; early_stopping:\n            bnds_temp = self._bounds(results[3])\n            tort_grid = [bnds_temp[3][0],(.75*bnds_temp[3][0]+.25*bnds_temp[3][1]),(.5*bnds_temp[3][0]+.5*bnds_temp[3][1]),(.25*bnds_temp[3][0]+.75*bnds_temp[3][1]),bnds_temp[3][1]]\n            vcl_grid = [bnds_temp[4][0],(.75*bnds_temp[4][0]+.25*bnds_temp[4][1]),(.5*bnds_temp[4][0]+.5*bnds_temp[4][1]),(.25*bnds_temp[4][0]+.75*bnds_temp[4][1]),bnds_temp[4][1]]\n            tcl_grid = [bnds_temp[5][0],(.75*bnds_temp[5][0]+.25*bnds_temp[5][1]),(.5*bnds_temp[5][0]+.5*bnds_temp[5][1]),(.25*bnds_temp[5][0]+.75*bnds_temp[5][1]),bnds_temp[5][1]]\n\n            loop_len = len(tort_grid)*len(vcl_grid)*len(tcl_grid)\n            i = 1\n\n            for to in tort_grid: \n                for v in vcl_grid:\n                    for tc in tcl_grid:\n                        phi = self.porosity\n                        fr = self.flow_resistivity\n                        t = self.thickness\n                        air = self.air_gap\n                        x0 = [t,fr,phi,to,v,tc,air]\n\n                        grid_search = round((i/loop_len)*100,2)\n                        bnds = self._bounds(results[3])\n                        res2 = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n\n                        if verbose == True:\n                            print(f\"{grid_search}% of the parameter space has been searched. The current lowest error is: {err}\")\n\n\n                        if res2.fun &lt; err:\n                            err = res2.fun\n                            results = np.around(res2.x,decimals=3)\n\n                            if err &lt; early_stopping:\n                                result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}\n                                if verbose == True:\n                                    print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n                                return(result_dict)\n                        i+=1\n\n\n            print(\"Warning: stopping criterion not met during parameter search. Double check known inputs and/or consider increasing the uncertainty value of the knowns.\")\n            result_dict = {'thickness': results[0],\n                           'flow resistivity': results[1],\n                           'porosity': results[2],\n                           'tortuosity': results[3],\n                           'viscous characteristic length': results[4],\n                           'thermal characteristic length': results[5],\n                           'air gap': results[6],\n                           'error': err}\n\n            return(result_dict)\n\n\n    def stats(self,\n              parameters:dict) -&gt; dict:\n        \"\"\"\n        Calculates statistics about the parameters identified in the optimization routine via linear regression of the predicted vs measured\n        absorption coefficients.\n\n        Parameters\n        ----------\n        parameters (dict):\n            dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n            viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n        Returns\n        -------\n        stats (dict):\n            dictionary containing the slope, intercept, r value, p value, and std error returned from the linear regression.\n            If 'Dual' opt_type is specified, the statistics for each mounting condition are averaged.\n\n        \"\"\"\n        if self.opt_type == 'No Gap':\n            x = self.meas_abs[0]\n            y = self._predictionJCA(parameters)\n\n            slope,intercept,r_value,p_value,std_err = scipy.stats.linregress(x,y)\n            stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n            return(stats)\n\n        elif self.opt_type == 'Gap':\n            x = self.meas_abs[1]\n            y = self._predictionJCA(parameters)\n\n            slope,intercept,r_value,p_value,std_err = scipy.stats.linregress(x,y)\n            stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n            return(stats)\n\n        elif self.opt_type == 'Dual':\n            x1 = self.meas_abs[0]\n            y1 = self._predictionJCA(parameters)[0]\n\n            slope1,intercept1,r_value1,p_value1,std_err1 = scipy.stats.linregress(x1,y1)\n\n            x2 = self.meas_abs[1]\n            y2 = self._predictionJCA(parameters)[1]\n\n            slope2,intercept2,r_value2,p_value2,std_err2 = scipy.stats.linregress(x2,y2)\n\n            slope = np.abs((slope1+slope2)/2)\n            intercept = np.abs((intercept1+intercept2)/2)\n            r_value = np.abs((r_value1+r_value2)/2)\n            p_value = np.abs((p_value1+p_value2)/2)\n            std_err = np.abs((std_err1+std_err2)/2)\n\n            stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n            return(stats)\n\n    def plot_comparison(self,\n                        parameters:dict) -&gt; None:\n        \"\"\"\n        Plots the predicted and measured frequency dependent absorption coefficients.\n\n        Parameters\n        ----------\n        parameters (dict):\n            dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n            viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n        \"\"\"\n\n        f, ax = plt.subplots(1)\n\n        if self.opt_type == 'No Gap':\n            actual = self.meas_abs[0]\n            predicted = self._predictionJCA(parameters)\n\n            ax.plot(self.frequency,actual,label='Actual')\n            ax.plot(self.frequency,predicted,label='Predicted')\n\n            ax.legend(loc=\"lower right\")\n            ax.set_ylim(bottom=0)\n\n            plt.show()\n\n\n        elif self.opt_type == 'Gap':\n            actual = self.meas_abs[1]\n            predicted = self._predictionJCA(parameters)\n\n            ax.plot(self.frequency,actual,label='Actual')\n            ax.plot(self.frequency,predicted,label='Predicted')\n\n            ax.legend(loc=\"lower right\")\n            ax.set_ylim(bottom=0)\n\n            plt.show()\n\n        elif self.opt_type == 'Dual':\n            no_gap_pred = self._predictionJCA(parameters)[0]\n            gap_pred = self._predictionJCA(parameters)[1]\n            no_gap_actual = self.meas_abs[0]\n            gap_actual = self.meas_abs[1]\n\n            ax.plot(self.frequency,no_gap_actual,label='No Gap Actual')\n            ax.plot(self.frequency,no_gap_pred,label='No Gap Predicted')\n            ax.plot(self.frequency,gap_actual,label='Gap Actual')\n            ax.plot(self.frequency,gap_pred,label='Gap Predicted')\n\n            ax.legend(loc=\"lower right\")\n            ax.set_ylim(bottom=0)\n\n            plt.show()\n\n    def to_csv(self,\n               FileName: str,\n               parameters: dict) -&gt; None:\n        \"\"\"\n        Saves the identified parameters and the measured/predicted absorption curves to a csv file.\n\n        Parameters\n        ----------\n        FileName (str):\n            Name of the csv file to save data to.\n\n        parameters (dict):\n            dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n            viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n        \"\"\"\n\n        if \".csv\" in FileName:\n            file = FileName\n        else:\n            file = FileName+\".csv\"\n\n\n        if self.opt_type == 'No Gap':\n            actual = self.meas_abs[0]\n            predicted = self._predictionJCA(parameters)\n            all_data = {'frequency':self.frequency,'measured':actual,'predicted':predicted}\n\n\n        elif self.opt_type == 'Gap':\n            actual = self.meas_abs[1]\n            predicted = self._predictionJCA(parameters)\n            all_data = {'frequency':self.frequency,'measured':actual,'predicted':predicted}\n\n        elif self.opt_type == 'Dual':\n            no_gap_pred = self._predictionJCA(parameters)[0]\n            gap_pred = self._predictionJCA(parameters)[1]\n            no_gap_actual = self.meas_abs[0]\n            gap_actual = self.meas_abs[1]\n\n            all_data = {'frequency':self.frequency,'no gap measured':no_gap_actual,'no gap predicted':no_gap_pred,'gap measured':gap_actual,'gap predicted':gap_pred}\n\n        with open(file, 'w') as f:\n            [f.write('{0},{1}\\n'.format(key, value)) for key, value in parameters.items()]\n            writer = csv.writer(f, delimiter = \",\",lineterminator='\\n')\n            writer.writerow(all_data.keys())\n            writer.writerows(zip(*all_data.values()))\n\n    def load_to_array(self,\n                      FileName: str,\n                      type: str ='complex') -&gt; None:\n        \"\"\"\n        Loads data from csv or excel file.\n\n        Parameters\n        ----------\n        FileName (str):\n            Name of the file to load data from\n\n        type (str):\n            type of data being loaded -- either complex or floating point data\n\n        \"\"\"\n        if type == 'complex':\n            try:\n                data = np.asarray(pd.read_csv(FileName,header=None).map(lambda s: np.complex128(s.replace('i', 'j'))))\n            except Exception:\n                data = np.asarray(pd.read_excel(FileName,header=None).map(lambda s: np.complex128(s.replace('i', 'j'))))\n\n        elif type == 'float':\n            try:\n                data = np.asarray(pd.read_csv(FileName,header=None))\n            except Exception:\n                data = np.asarray(pd.read_excel(FileName,header=None))  \n\n        return (data)\n\n    def to_database(self,\n                    parameters: dict,\n                    layer_name: str) -&gt; None:\n        \"\"\"\n        Saves the identified parameters as a new layer in a database.\n\n        Parameters\n        ----------\n        parameters (dict):\n            dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n            viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n        layer_name (str):\n            Specifies the name of the layer.  Must be a unique identifier.\n        \"\"\"\n\n        thickness = parameters['thickness']\n        flow_resistivity = parameters['flow resistivity']\n        porosity = parameters['porosity']\n        tortuosity = parameters['tortuosity']\n        viscous_characteristic_length = parameters['viscous characteristic length']\n        thermal_characteristic_length = parameters['thermal characteristic length']\n\n        s = AcoustiBase()\n        data = s.pull('LAYER')\n        id1 = len(data)+1\n        params = [id1,layer_name,'identified','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,'null','null','null','null','null','null']\n        s.execute(params,'LAYER')\n        s.commit()\n        s.close()\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._predictionJCA","title":"<code>_predictionJCA(parameters)</code>","text":"<p>Calculates the predicted frequency dependent absorption curve using the parameters identified in the optimization procedure defined in the find_values methods</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._predictionJCA--parameters","title":"Parameters","text":"<p>parameters (dict):     dictionary containing the identified thickness, flow resistivity, porosity, tortuosity,      viscous characteristic length, thermal characteristic length, and air gap of the sample.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._predictionJCA--returns","title":"Returns","text":"<p>predicted (ndarray):     2D array of frequencies and predicted absorption coefficients</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def _predictionJCA(self,\n                   parameters: dict) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the predicted frequency dependent absorption curve using the parameters identified in the\n    optimization procedure defined in the find_values methods\n\n    Parameters\n    ----------\n    parameters (dict):\n        dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n        viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n    Returns\n    -------\n    predicted (ndarray):\n        2D array of frequencies and predicted absorption coefficients \n\n    \"\"\"\n\n    dummy_struct = AcousticTMM(air_temperature=self.temp,\n                               sound_speed=self.soundspeed_temp,\n                               air_density=self.density_temp,\n                               Cp=self.Cp,\n                               Cv=self.Cv,\n                               viscosity=self.viscosity_temp,\n                               Pr=self.Pr_temp,\n                               P0=self.P0)\n\n    t = parameters['thickness']\n    fr = parameters['flow resistivity']\n    phi = parameters['porosity']\n    tort = parameters['tortuosity']\n    vcl = parameters['viscous characteristic length']\n    tcl = parameters['thermal characteristic length']\n    air_gap = parameters['air gap']\n\n    layer = dummy_struct.Add_JCA_Layer(t,fr,phi,tort,vcl,tcl)\n    air = dummy_struct.Add_Air_Layer(thickness = air_gap)\n    dummy_struct.frequency = self.frequency\n\n    if self.opt_type == 'Gap' or self.opt_type == 'No Gap':\n        s = dummy_struct.assemble_structure(layer,air)\n        predicted = dummy_struct.absorption(s)[:,1]\n        return(predicted)\n\n    elif self.opt_type == 'Dual':\n        no_gap_s = dummy_struct.assemble_structure(layer)\n        gap_s = dummy_struct.assemble_structure(layer,air)\n\n        no_gap_pred = dummy_struct.absorption(no_gap_s)[:,1]\n        gap_pred = dummy_struct.absorption(gap_s)[:,1]\n\n        return([no_gap_pred,gap_pred])\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._error","title":"<code>_error(x)</code>","text":"<p>Function that is minimized in the optimization routine. Calculates the error between the measured (impedance tube) and predicted (TMM) absorption coefficients.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._error--parameters","title":"Parameters","text":"<p>x (list):     list structure containing the identified thickness, flow resistivity, porosity, tortuosity, viscous characteristic length,     thermal characteristic length, and air gap thickness of the sample (in that order).</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._error--returns","title":"Returns","text":"<p>err (float):     if opt_type is 'No Gap' or 'Gap' --&gt; sum of the absolute square difference between measured and predicted absorption coefficients across all specified frequencies.     if opt_type is 'Dual', the error for each mounting condition is averaged into a single error metric</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def _error(self,\n           x: list) -&gt; float:\n    \"\"\"\n    Function that is minimized in the optimization routine. Calculates the error between the measured (impedance tube)\n    and predicted (TMM) absorption coefficients.\n\n    Parameters\n    ----------\n    x (list):\n        list structure containing the identified thickness, flow resistivity, porosity, tortuosity, viscous characteristic length,\n        thermal characteristic length, and air gap thickness of the sample (in that order).\n\n    Returns\n    -------\n    err (float):\n        if opt_type is 'No Gap' or 'Gap' --&gt; sum of the absolute square difference between measured and predicted absorption coefficients across all specified frequencies.\n        if opt_type is 'Dual', the error for each mounting condition is averaged into a single error metric\n\n    \"\"\"\n\n    t = x[0]\n    fr = x[1]\n    phi = x[2]\n    tort = x[3]\n    vcl = x[4]\n    tcl = x[5]\n    air = x[6]\n\n    params = {'thickness':t,'flow resistivity':fr,'porosity':phi,'tortuosity':tort,'viscous characteristic length':vcl,'thermal characteristic length':tcl,'air gap':air}\n\n    A = self._predictionJCA(params)\n\n    if self.opt_type == 'No Gap':\n        err = np.sum(np.abs(np.diff(A-self.meas_abs[0]))**2)\n        return(err)\n\n    elif self.opt_type == 'Gap':\n        err = np.sum(np.abs(np.diff(A-self.meas_abs[1]))**2)\n        return(err)\n\n    elif self.opt_type == 'Dual':\n        err = (np.sum(np.abs(np.diff(A[0]-self.meas_abs[0]))**2)+np.sum(np.abs(np.diff(A[1]-self.meas_abs[1]))**2))/2\n        return(err)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._bounds","title":"<code>_bounds(tort)</code>","text":"<p>Defines the lower and upper boundary values for the parameters in the optimization routine. Bounds for thickness, flow resistivity, porosity, and air gap are calculated using the supplied \"known\" values and the uncertainty.  Tortuosity, viscous, and thermal characteristic length bounds are defined in:</p> <p>Atalla, Youssef &amp; Panneton, R.. (2005). Inverse acoustical characterization of open cell porous  media using impedance tube measurements. Canadian Acoustics - Acoustique Canadienne. 33.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._bounds--parameters","title":"Parameters","text":"<p>tort (float):     tortuosity --&gt; defined either as the initial guess or the most recent value returned by the optimization routine.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID._bounds--returns","title":"Returns","text":"<p>bounds (tuple):     contains tuples of the lower and upper bounds for each parameter.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def _bounds(self,\n            tort: float) -&gt; tuple:\n    \"\"\"\n    Defines the lower and upper boundary values for the parameters in the optimization routine. Bounds for thickness, flow resistivity,\n    porosity, and air gap are calculated using the supplied \"known\" values and the uncertainty.  Tortuosity, viscous, and thermal characteristic\n    length bounds are defined in:\n\n    Atalla, Youssef &amp; Panneton, R.. (2005). Inverse acoustical characterization of open cell porous \n    media using impedance tube measurements. Canadian Acoustics - Acoustique Canadienne. 33.\n\n    Parameters\n    ----------\n    tort (float):\n        tortuosity --&gt; defined either as the initial guess or the most recent value returned by the optimization routine.\n\n    Returns\n    -------\n    bounds (tuple):\n        contains tuples of the lower and upper bounds for each parameter.\n\n    \"\"\"\n\n    l_unc = 1-self.uncertainty\n    u_unc = 1+self.uncertainty\n\n    t_lb = l_unc*self.thickness\n    t_ub = u_unc*self.thickness\n\n\n    fr_lb = l_unc*self.flow_resistivity\n    fr_ub = u_unc*self.flow_resistivity\n\n    phi_lb = l_unc*self.porosity\n    phi_ub = u_unc*self.porosity\n\n    air_lb = l_unc*self.air_gap\n    air_ub = u_unc*self.air_gap\n\n    tort_lb = 1\n    tort_ub = 4\n\n    vcl_lb = ((1/3.3)*np.sqrt((8*tort*self.viscosity_temp)/(self.flow_resistivity*self.porosity)))/(1e-6)\n    vcl_ub =((1/.3)*np.sqrt((8*tort*self.viscosity_temp)/(self.flow_resistivity*self.porosity)))/(1e-6)\n\n    tcl_lb = vcl_lb\n    tcl_ub = vcl_ub\n\n    tort_b = (tort_lb,tort_ub)\n    vcl_b = (vcl_lb,vcl_ub)\n    tcl_b = (tcl_lb,tcl_ub)\n    phi_b = (phi_lb,phi_ub)\n    fr_b = (fr_lb,fr_ub)\n    t_b = (t_lb,t_ub)\n    air_b = (air_lb,air_ub)\n\n    bounds = (t_b,fr_b,phi_b,tort_b,vcl_b,tcl_b,air_b)\n\n    return (bounds)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Inverse","title":"<code>Inverse(thickness, flow_resistivity, porosity, air_gap=0, uncertainty=0.01, early_stopping=1e-15, verbose=False)</code>","text":"<p>Optimization routine for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths). The routine uses the Sequential Least Squares Programming method (https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html) to minimize the error between predicted and actual absorption coefficients.</p> <p>If the early stopping criterion is not met after an initial guess, a unique grid search of the parameter space is crafted to help ensure the global minimum is found (ie the correct values for the parameters are identified).</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Inverse--parameters","title":"Parameters","text":"<p>thickness (float):     The measured thickness of the sample [mm]</p> <p>flow_resistivity (float):     The measured flow resistivity of the sample [Pa*s/m2]</p> <p>porosity (float):     The measured porosity of the sample [-]</p> <p>air_gap (float):     The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]</p> <p>uncertainty (float):     A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements     of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.</p> <p>early_stopping (float):     criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate     and return the results. The default value of 1e-15 has been tested on a number of simulated cases.</p> <p>verbose (bool):      If true, the progress of the optimization routine will print to the console.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Inverse--returns","title":"Returns","text":"<p>result_dict (dict):     dictionary containing the identified parameters associated with the lowest calculated error.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def Inverse(self,\n            thickness: float,\n            flow_resistivity: float,\n            porosity: float,\n            air_gap: float=0,\n            uncertainty: float=0.01,\n            early_stopping: float=1e-15,\n            verbose: bool=False) -&gt; dict:\n    \"\"\"\n    Optimization routine for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths).\n    The routine uses the Sequential Least Squares Programming method (https://docs.scipy.org/doc/scipy/reference/optimize.minimize-slsqp.html)\n    to minimize the error between predicted and actual absorption coefficients.\n\n    If the early stopping criterion is not met after an initial guess, a unique grid search of the parameter space is crafted to help ensure\n    the global minimum is found (ie the correct values for the parameters are identified).\n\n    Parameters\n    ----------\n    thickness (float):\n        The measured thickness of the sample [mm]\n\n    flow_resistivity (float):\n        The measured flow resistivity of the sample [Pa*s/m2]\n\n    porosity (float):\n        The measured porosity of the sample [-]\n\n    air_gap (float):\n        The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n    uncertainty (float):\n        A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements\n        of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.\n\n    early_stopping (float):\n        criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate\n        and return the results. The default value of 1e-15 has been tested on a number of simulated cases.\n\n    verbose (bool):\n         If true, the progress of the optimization routine will print to the console.\n\n    Returns\n    -------\n    result_dict (dict):\n        dictionary containing the identified parameters associated with the lowest calculated error.\n\n    \"\"\"\n    self.thickness = thickness\n    self.flow_resistivity = flow_resistivity\n    self.porosity = porosity\n    self.air_gap = air_gap\n\n    if uncertainty &gt;= 0 and uncertainty &lt;= 1:\n        self.uncertainty = uncertainty\n\n    else:\n        print(\"Uncertainty must be between 0 and 1, reverting to default uncertainty of 1.0%!\")\n        self.uncertainty = 0.01\n\n    init_tort = 2.5\n\n    bnds = self._bounds(init_tort)\n    x0 = [self.thickness,self.flow_resistivity,self.porosity,init_tort,(bnds[4][1]-bnds[4][0])/2,(bnds[5][1]-bnds[5][0])/2,self.air_gap] \n    cons = ({'type':'ineq','fun':lambda x:x[5]-x[4]})\n    res = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n    err = res.fun\n    results = np.around(res.x,decimals=3)\n\n    if err &lt; early_stopping:\n        result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}  \n        if verbose == True:\n            print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n        return(result_dict)\n\n    elif err &gt; early_stopping:\n        bnds_temp = self._bounds(results[3])\n        tort_grid = [bnds_temp[3][0],(.75*bnds_temp[3][0]+.25*bnds_temp[3][1]),(.5*bnds_temp[3][0]+.5*bnds_temp[3][1]),(.25*bnds_temp[3][0]+.75*bnds_temp[3][1]),bnds_temp[3][1]]\n        vcl_grid = [bnds_temp[4][0],(.75*bnds_temp[4][0]+.25*bnds_temp[4][1]),(.5*bnds_temp[4][0]+.5*bnds_temp[4][1]),(.25*bnds_temp[4][0]+.75*bnds_temp[4][1]),bnds_temp[4][1]]\n        tcl_grid = [bnds_temp[5][0],(.75*bnds_temp[5][0]+.25*bnds_temp[5][1]),(.5*bnds_temp[5][0]+.5*bnds_temp[5][1]),(.25*bnds_temp[5][0]+.75*bnds_temp[5][1]),bnds_temp[5][1]]\n\n        loop_len = len(tort_grid)*len(vcl_grid)*len(tcl_grid)\n        i = 1\n\n        for to in tort_grid: \n            for v in vcl_grid:\n                for tc in tcl_grid:\n                    phi = self.porosity\n                    fr = self.flow_resistivity\n                    t = self.thickness\n                    air = self.air_gap\n                    x0 = [t,fr,phi,to,v,tc,air]\n\n                    grid_search = round((i/loop_len)*100,2)\n                    bnds = self._bounds(results[3])\n                    res2 = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n\n                    if verbose == True:\n                        print(f\"{grid_search}% of the parameter space has been searched. The current lowest error is: {err}\")\n\n\n                    if res2.fun &lt; err:\n                        err = res2.fun\n                        results = np.around(res2.x,decimals=3)\n\n                        if err &lt; early_stopping:\n                            result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}\n                            if verbose == True:\n                                print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n                            return(result_dict)\n                    i+=1\n\n\n        print(\"Warning: stopping criterion not met during parameter search. Double check known inputs and/or consider increasing the uncertainty value of the knowns.\")\n        result_dict = {'thickness': results[0],\n                       'flow resistivity': results[1],\n                       'porosity': results[2],\n                       'tortuosity': results[3],\n                       'viscous characteristic length': results[4],\n                       'thermal characteristic length': results[5],\n                       'air gap': results[6],\n                       'error': err}\n\n        return(result_dict)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Indirect","title":"<code>Indirect(thickness, porosity, flow_resistivity=None, air_gap=0)</code>","text":"<p>Indirect method for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths), based on:</p> <p>Panneton, R. &amp; Salissou, Yacoubou. (2009). Indirect acoustical characterization of sound absorbing materials..  The Journal of the Acoustical Society of America. 126. 2297. 10.1121/1.3249416.</p> <p>This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples and  it is susceptible to uncertainty in the measurements of thickness, porosity, flow resistivity, air gap,  and the acoustic indicator(s) -- but the advantage is that it does not require a flow resistivity measurement in order to  estimate the JCA parameters.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Indirect--parameters","title":"Parameters","text":"<p>thickness (float):     The measured thickness of the sample [mm]</p> <p>porosity (float):     The measured porosity of the sample [-]</p> <p>flow_resistivity (float):     Optional, the measured flow resistivity of the sample [Pa*s/m2].  If no flow resistivity is specified, the value     will be estimated automatically.</p> <p>air_gap (float):     The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Indirect--returns","title":"Returns","text":"<p>result_dict (dict):     dictionary containing the identified parameters associated with the lowest calculated error.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def Indirect(self,\n             thickness: float,\n             porosity: float,\n             flow_resistivity: float=None,\n             air_gap: float=0) -&gt; dict:\n    \"\"\"\n    Indirect method for identifying the hard-to-measure JCA parameters (tortuosity, viscous, and thermal characteristic lengths), based on:\n\n    Panneton, R. &amp; Salissou, Yacoubou. (2009). Indirect acoustical characterization of sound absorbing materials.. \n    The Journal of the Acoustical Society of America. 126. 2297. 10.1121/1.3249416.\n\n    This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples and \n    it is susceptible to uncertainty in the measurements of thickness, porosity, flow resistivity, air gap, \n    and the acoustic indicator(s) -- but the advantage is that it does not require a flow resistivity measurement in order to \n    estimate the JCA parameters.\n\n    Parameters\n    ----------\n    thickness (float):\n        The measured thickness of the sample [mm]\n\n    porosity (float):\n        The measured porosity of the sample [-]\n\n    flow_resistivity (float):\n        Optional, the measured flow resistivity of the sample [Pa*s/m2].  If no flow resistivity is specified, the value\n        will be estimated automatically.\n\n    air_gap (float):\n        The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n    Returns\n    -------\n    result_dict (dict):\n        dictionary containing the identified parameters associated with the lowest calculated error.\n\n    \"\"\"\n\n    self.thickness = thickness\n    self.porosity = porosity\n    self.air_gap = air_gap\n\n    if flow_resistivity == None:\n        self.flow_resistivity = None\n        return_preds = True\n    else:\n        self.flow_resistivity = flow_resistivity\n        return_preds = False\n\n    air_gap = self.air_gap/1000\n    thickness = self.thickness/1000\n    w = 2*np.pi*self.frequency\n    k0 = w / self.soundspeed_temp\n\n    if self.input_type == 'absorption':\n        raise ValueError('Absorption data cannot be used for Indirect characterizations, please specify reflection or surface impedance data')\n\n    elif self.opt_type == 'Gap' or self.opt_type == 'No Gap':\n        raise ValueError('Dual mount types are required for Indirect characterizations')\n\n    elif self.input_type == 'surface':\n        Zs_NG = self.no_gap_data[:,1]\n        Zs_G = self.gap_data[:,1]\n\n    elif self.input_type == 'reflection':\n        Zs_NG = self.Z0*((1+self.no_gap_data[:,1])/(1-self.no_gap_data[:,1]))\n        Zs_G = self.Z0*((1+self.gap_data[:,1])/(1-self.gap_data[:,1]))\n\n\n    T11A = np.cos(k0*air_gap)\n    T21A = (1j/self.Z0)*np.sin(k0*air_gap)\n    Zs_A = T11A/T21A\n\n    Zp = np.sqrt((Zs_NG*(Zs_G-Zs_A))+(Zs_G*Zs_A))\n    kp = np.arctan(Zp/(1j*Zs_NG))/thickness\n\n    test = np.column_stack((self.frequency,np.real(Zp/(1j*Zs_NG))))\n\n    try:\n        cutoff = test[np.where(test[:-1] * test[1:] &lt; 0 )[0]]\n        cutoff = np.abs(np.min(cutoff[:,0]))\n    except ValueError:\n        cutoff = np.max(self.frequency)\n\n    peff = Zp*kp/w\n    keff = w*np.divide(Zp,kp)\n\n    re_peff = np.real(peff)\n    im_peff = np.imag(peff)\n\n    fr = np.column_stack((self.frequency**2,-im_peff*w))\n    fr_curve = fr[np.where(fr[:,0] &lt;= cutoff**2)]\n    slope1,intercept1,r_value1,p_value1,std_err1 = scipy.stats.linregress(fr_curve[:,0],fr_curve[:,1])\n\n    jca_fr = np.abs(intercept1)\n\n    #######################################################################################################\n\n    if return_preds == False:\n        tort = (self.porosity/self.density_temp)*(re_peff-np.sqrt((im_peff**2)-((self.flow_resistivity/w)**2)))\n    elif return_preds == True:\n        tort = (self.porosity/self.density_temp)*(re_peff-np.sqrt((im_peff**2)-((jca_fr/w)**2)))\n    tort1 = np.column_stack((self.frequency,tort))\n    tort_curve = tort1[np.where(tort1[:,0] &lt;= cutoff )]\n    jca_tort = np.abs(np.mean(tort_curve[:,1]))\n\n    #######################################################################################################\n\n    phi_num = (self.density_temp*jca_tort)\n    if return_preds == False:\n        phi_denom = re_peff-np.sqrt((im_peff**2)-((self.flow_resistivity/w)**2))\n    elif return_preds == True:\n        phi_denom = re_peff-np.sqrt((im_peff**2)-((jca_fr/w)**2))\n    phi = phi_num/phi_denom\n    phi1 = np.column_stack((self.frequency,phi))\n    phi_curve = phi1[np.where((phi1[:,0] &lt;= cutoff) &amp; (phi1[:,0] &gt;= 500))]\n    jca_phi = np.abs(np.mean(phi_curve[:,1]))\n\n    ####################################################################################################### \n\n    if return_preds == False:\n        vcl = jca_tort*np.sqrt((2*self.density_temp*self.viscosity_temp)/((w*self.porosity*im_peff)*((self.density_temp*jca_tort)-(self.porosity*re_peff))))/(1e-6)\n    elif return_preds == True:\n        vcl = jca_tort*np.sqrt((2*self.density_temp*self.viscosity_temp)/((w*jca_phi*im_peff)*((self.density_temp*jca_tort)-(jca_phi*re_peff))))/(1e-6)\n    vcl1 = np.column_stack((self.frequency,vcl))\n    vcl_curve = vcl1[np.where(vcl1[:,0] &lt;= cutoff )]\n    jca_vcl = np.abs(np.mean(vcl_curve[:,1]))\n\n    #######################################################################################################        \n\n    tcl0 = np.sqrt((2*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp))\n    if return_preds == False:\n        tcl1 = ((1-((keff*self.porosity)/(self.gamma_temp*self.P0)))/(1-((keff*self.porosity)/self.P0)))**2\n    elif return_preds == True:\n        tcl1 = ((1-((keff*jca_phi)/(self.gamma_temp*self.P0)))/(1-((keff*jca_phi)/self.P0)))**2\n    tcl2 = 1/(-np.imag(tcl1))\n    tcl3 = np.sqrt(2*tcl2)       \n    tcl4 = tcl0*tcl3/(1e-6)\n    tcl5 = np.column_stack((self.frequency,tcl4))\n    tcl_curve = tcl5[np.where((tcl5[:,0] &lt;= cutoff) &amp; (tcl5[:,0] &gt;= 500))]\n    jca_tcl = np.abs(np.mean(tcl_curve[:,1]))\n\n    #######################################################################################################           \n\n    if return_preds == False:\n        kn0 = (self.porosity*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp)\n    elif return_preds == True:\n        kn0 = (jca_phi*self.viscosity_temp)/(w*self.density_temp*self.Pr_temp)\n    kn1 = 1/np.sqrt(-np.real(tcl1))\n    kn3 = kn0*kn1/(1e-10)\n    kn4 = np.column_stack((self.frequency,kn3))\n    k0_curve = kn4[np.where((kn4[:,0] &lt;= cutoff) &amp; (kn4[:,0] &gt;= 500))]\n    jca_k0 = np.abs(np.mean(k0_curve[:,1]))\n\n    result_dict = {'thickness': self.thickness,\n                   'flow resistivity': self.flow_resistivity,\n                   'porosity': self.porosity,\n                   'tortuosity': round(jca_tort,4),\n                    'viscous characteristic length': round(jca_vcl,4),\n                    'thermal characteristic length': round(jca_tcl,4),\n                    'air gap': self.air_gap} \n\n    full_predicted_dict = {'thickness': self.thickness,\n                           'flow resistivity': jca_fr,\n                           'porosity': jca_phi,\n                           'tortuosity': jca_tort,\n                           'viscous characteristic length': jca_vcl,\n                           'thermal characteristic length': jca_tcl,\n                           'air gap': self.air_gap} \n\n    if return_preds == False:\n        return(result_dict)\n\n    elif return_preds == True:\n        return(full_predicted_dict)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Hybrid","title":"<code>Hybrid(thickness, porosity, flow_resistivity=None, air_gap=0, uncertainty=0.01, early_stopping=1e-15, verbose=False)</code>","text":"<p>The Hybrid routine uses both the inverse and indirect characterization methods to identify the JCA parameters.  The parameters are  first estimated using the indirect method and the error between measured and estimated absorption coefficients is determined.</p> <p>If the early stopping criterion is not met using the indirect method, the estimate is then used as the initial guess for the inverse procedure and to calculate the bounds of the grid search.</p> <p>This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples. The advantage of using this procedure compared to the inverse or indirect methods alone are:     Inverse: The Hybrid method does not require flow resitivity to be known.     Indirect:  The Hybrid method is much less susceptible to uncertainty in the measurements.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Hybrid--parameters","title":"Parameters","text":"<p>thickness (float):     The measured thickness of the sample [mm]</p> <p>flow_resistivity (float):     The measured flow resistivity of the sample [Pa*s/m2]</p> <p>porosity (float):     The measured porosity of the sample [-]</p> <p>air_gap (float):     The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]</p> <p>uncertainty (float):     A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements     of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.</p> <p>early_stopping (float):     criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate     and return the results. The default value of 1e-15 has been tested on a number of simulated cases.</p> <p>verbose (bool):      If true, the progress of the optimization routine will print to the console.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.Hybrid--returns","title":"Returns","text":"<p>result_dict (dict):     dictionary containing the identified parameters associated with the lowest calculated error.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def Hybrid(self,\n           thickness: float,\n           porosity: float,\n           flow_resistivity: float=None,\n           air_gap: float=0,\n           uncertainty: float=0.01,\n           early_stopping: float=1e-15,\n           verbose: bool=False) -&gt; dict:\n    \"\"\"\n    The Hybrid routine uses both the inverse and indirect characterization methods to identify the JCA parameters.  The parameters are \n    first estimated using the indirect method and the error between measured and estimated absorption coefficients is determined.\n\n    If the early stopping criterion is not met using the indirect method, the estimate is then used as the initial guess for the inverse\n    procedure and to calculate the bounds of the grid search.\n\n    This method requires 'Dual' mounting conditions and either reflection or surface impedance measurements of the samples.\n    The advantage of using this procedure compared to the inverse or indirect methods alone are:\n        Inverse: The Hybrid method does not require flow resitivity to be known.\n        Indirect:  The Hybrid method is much less susceptible to uncertainty in the measurements.\n\n    Parameters\n    ----------\n    thickness (float):\n        The measured thickness of the sample [mm]\n\n    flow_resistivity (float):\n        The measured flow resistivity of the sample [Pa*s/m2]\n\n    porosity (float):\n        The measured porosity of the sample [-]\n\n    air_gap (float):\n        The measured impedance tube air gap behind the sample, if 'Gap' or 'Dual' mounting conditions are specified [mm]\n\n    uncertainty (float):\n        A measure of how uncertain the user is in the thickness, flow resistivity, porosity, and air gap measurements\n        of the sample [0 - 1].  Increasing the uncertainty value will result in a wider search of the parameter space.\n\n    early_stopping (float):\n        criterion for ending the search early.  If the calculated error at any given step is less than this value, the routine will terminate\n        and return the results. The default value of 1e-15 has been tested on a number of simulated cases.\n\n    verbose (bool):\n         If true, the progress of the optimization routine will print to the console.\n\n    Returns\n    -------\n    result_dict (dict):\n        dictionary containing the identified parameters associated with the lowest calculated error.\n\n    \"\"\"\n    self.thickness = thickness\n    self.porosity = porosity\n    self.air_gap = air_gap\n    if uncertainty &gt;= 0 and uncertainty &lt;= 1:\n        self.uncertainty = uncertainty\n\n    else:\n        print(\"Uncertainty must be between 0 and 1, reverting to default uncertainty of 1.0%!\")\n        self.uncertainty = 0.01\n\n\n    indirect_results = self.Indirect(self.thickness,self.porosity,flow_resistivity,self.air_gap)\n\n    if np.isnan(indirect_results['thermal characteristic length']):\n        indirect_results['thermal characteristic length'] = indirect_results['viscous characteristic length']\n\n    self.flow_resistivity = indirect_results['flow resistivity']\n\n    init_tort = indirect_results['tortuosity']\n\n    bnds = self._bounds(init_tort)\n    x0 = [self.thickness,indirect_results['flow resistivity'],indirect_results['porosity'],init_tort,indirect_results['viscous characteristic length'],indirect_results['thermal characteristic length'],self.air_gap] \n    cons = ({'type':'ineq','fun':lambda x:x[5]-x[4]})\n    res = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n    err = res.fun\n    results = np.around(res.x,decimals=3)\n\n    if err &lt; early_stopping:\n        result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}  \n        if verbose == True:\n            print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n        return(result_dict)\n\n    elif err &gt; early_stopping:\n        bnds_temp = self._bounds(results[3])\n        tort_grid = [bnds_temp[3][0],(.75*bnds_temp[3][0]+.25*bnds_temp[3][1]),(.5*bnds_temp[3][0]+.5*bnds_temp[3][1]),(.25*bnds_temp[3][0]+.75*bnds_temp[3][1]),bnds_temp[3][1]]\n        vcl_grid = [bnds_temp[4][0],(.75*bnds_temp[4][0]+.25*bnds_temp[4][1]),(.5*bnds_temp[4][0]+.5*bnds_temp[4][1]),(.25*bnds_temp[4][0]+.75*bnds_temp[4][1]),bnds_temp[4][1]]\n        tcl_grid = [bnds_temp[5][0],(.75*bnds_temp[5][0]+.25*bnds_temp[5][1]),(.5*bnds_temp[5][0]+.5*bnds_temp[5][1]),(.25*bnds_temp[5][0]+.75*bnds_temp[5][1]),bnds_temp[5][1]]\n\n        loop_len = len(tort_grid)*len(vcl_grid)*len(tcl_grid)\n        i = 1\n\n        for to in tort_grid: \n            for v in vcl_grid:\n                for tc in tcl_grid:\n                    phi = self.porosity\n                    fr = self.flow_resistivity\n                    t = self.thickness\n                    air = self.air_gap\n                    x0 = [t,fr,phi,to,v,tc,air]\n\n                    grid_search = round((i/loop_len)*100,2)\n                    bnds = self._bounds(results[3])\n                    res2 = minimize(self._error,x0,method='SLSQP',bounds=bnds,constraints=cons,tol = 1e-50,options={'ftol':1e-50, 'maxiter':1000})\n\n                    if verbose == True:\n                        print(f\"{grid_search}% of the parameter space has been searched. The current lowest error is: {err}\")\n\n\n                    if res2.fun &lt; err:\n                        err = res2.fun\n                        results = np.around(res2.x,decimals=3)\n\n                        if err &lt; early_stopping:\n                            result_dict = {'thickness':results[0],'flow resistivity':results[1],'porosity':results[2],'tortuosity':results[3],'viscous characteristic length':results[4],'thermal characteristic length':results[5],'air gap':results[6],'error':err}\n                            if verbose == True:\n                                print(f\"Early stopping criteria has been met. The current lowest error is: {err}\")\n                            return(result_dict)\n                    i+=1\n\n\n        print(\"Warning: stopping criterion not met during parameter search. Double check known inputs and/or consider increasing the uncertainty value of the knowns.\")\n        result_dict = {'thickness': results[0],\n                       'flow resistivity': results[1],\n                       'porosity': results[2],\n                       'tortuosity': results[3],\n                       'viscous characteristic length': results[4],\n                       'thermal characteristic length': results[5],\n                       'air gap': results[6],\n                       'error': err}\n\n        return(result_dict)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.stats","title":"<code>stats(parameters)</code>","text":"<p>Calculates statistics about the parameters identified in the optimization routine via linear regression of the predicted vs measured absorption coefficients.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.stats--parameters","title":"Parameters","text":"<p>parameters (dict):     dictionary containing the identified thickness, flow resistivity, porosity, tortuosity,      viscous characteristic length, thermal characteristic length, and air gap of the sample.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.stats--returns","title":"Returns","text":"<p>stats (dict):     dictionary containing the slope, intercept, r value, p value, and std error returned from the linear regression.     If 'Dual' opt_type is specified, the statistics for each mounting condition are averaged.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def stats(self,\n          parameters:dict) -&gt; dict:\n    \"\"\"\n    Calculates statistics about the parameters identified in the optimization routine via linear regression of the predicted vs measured\n    absorption coefficients.\n\n    Parameters\n    ----------\n    parameters (dict):\n        dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n        viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n    Returns\n    -------\n    stats (dict):\n        dictionary containing the slope, intercept, r value, p value, and std error returned from the linear regression.\n        If 'Dual' opt_type is specified, the statistics for each mounting condition are averaged.\n\n    \"\"\"\n    if self.opt_type == 'No Gap':\n        x = self.meas_abs[0]\n        y = self._predictionJCA(parameters)\n\n        slope,intercept,r_value,p_value,std_err = scipy.stats.linregress(x,y)\n        stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n        return(stats)\n\n    elif self.opt_type == 'Gap':\n        x = self.meas_abs[1]\n        y = self._predictionJCA(parameters)\n\n        slope,intercept,r_value,p_value,std_err = scipy.stats.linregress(x,y)\n        stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n        return(stats)\n\n    elif self.opt_type == 'Dual':\n        x1 = self.meas_abs[0]\n        y1 = self._predictionJCA(parameters)[0]\n\n        slope1,intercept1,r_value1,p_value1,std_err1 = scipy.stats.linregress(x1,y1)\n\n        x2 = self.meas_abs[1]\n        y2 = self._predictionJCA(parameters)[1]\n\n        slope2,intercept2,r_value2,p_value2,std_err2 = scipy.stats.linregress(x2,y2)\n\n        slope = np.abs((slope1+slope2)/2)\n        intercept = np.abs((intercept1+intercept2)/2)\n        r_value = np.abs((r_value1+r_value2)/2)\n        p_value = np.abs((p_value1+p_value2)/2)\n        std_err = np.abs((std_err1+std_err2)/2)\n\n        stats = {'slope':slope,'intercept':intercept,'r_value':r_value,'p_value':p_value,'std_err':std_err}\n\n        return(stats)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.plot_comparison","title":"<code>plot_comparison(parameters)</code>","text":"<p>Plots the predicted and measured frequency dependent absorption coefficients.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.plot_comparison--parameters","title":"Parameters","text":"<p>parameters (dict):     dictionary containing the identified thickness, flow resistivity, porosity, tortuosity,      viscous characteristic length, thermal characteristic length, and air gap of the sample.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def plot_comparison(self,\n                    parameters:dict) -&gt; None:\n    \"\"\"\n    Plots the predicted and measured frequency dependent absorption coefficients.\n\n    Parameters\n    ----------\n    parameters (dict):\n        dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n        viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n    \"\"\"\n\n    f, ax = plt.subplots(1)\n\n    if self.opt_type == 'No Gap':\n        actual = self.meas_abs[0]\n        predicted = self._predictionJCA(parameters)\n\n        ax.plot(self.frequency,actual,label='Actual')\n        ax.plot(self.frequency,predicted,label='Predicted')\n\n        ax.legend(loc=\"lower right\")\n        ax.set_ylim(bottom=0)\n\n        plt.show()\n\n\n    elif self.opt_type == 'Gap':\n        actual = self.meas_abs[1]\n        predicted = self._predictionJCA(parameters)\n\n        ax.plot(self.frequency,actual,label='Actual')\n        ax.plot(self.frequency,predicted,label='Predicted')\n\n        ax.legend(loc=\"lower right\")\n        ax.set_ylim(bottom=0)\n\n        plt.show()\n\n    elif self.opt_type == 'Dual':\n        no_gap_pred = self._predictionJCA(parameters)[0]\n        gap_pred = self._predictionJCA(parameters)[1]\n        no_gap_actual = self.meas_abs[0]\n        gap_actual = self.meas_abs[1]\n\n        ax.plot(self.frequency,no_gap_actual,label='No Gap Actual')\n        ax.plot(self.frequency,no_gap_pred,label='No Gap Predicted')\n        ax.plot(self.frequency,gap_actual,label='Gap Actual')\n        ax.plot(self.frequency,gap_pred,label='Gap Predicted')\n\n        ax.legend(loc=\"lower right\")\n        ax.set_ylim(bottom=0)\n\n        plt.show()\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.to_csv","title":"<code>to_csv(FileName, parameters)</code>","text":"<p>Saves the identified parameters and the measured/predicted absorption curves to a csv file.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.to_csv--parameters","title":"Parameters","text":"<p>FileName (str):     Name of the csv file to save data to.</p> <p>parameters (dict):     dictionary containing the identified thickness, flow resistivity, porosity, tortuosity,      viscous characteristic length, thermal characteristic length, and air gap of the sample.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def to_csv(self,\n           FileName: str,\n           parameters: dict) -&gt; None:\n    \"\"\"\n    Saves the identified parameters and the measured/predicted absorption curves to a csv file.\n\n    Parameters\n    ----------\n    FileName (str):\n        Name of the csv file to save data to.\n\n    parameters (dict):\n        dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n        viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n    \"\"\"\n\n    if \".csv\" in FileName:\n        file = FileName\n    else:\n        file = FileName+\".csv\"\n\n\n    if self.opt_type == 'No Gap':\n        actual = self.meas_abs[0]\n        predicted = self._predictionJCA(parameters)\n        all_data = {'frequency':self.frequency,'measured':actual,'predicted':predicted}\n\n\n    elif self.opt_type == 'Gap':\n        actual = self.meas_abs[1]\n        predicted = self._predictionJCA(parameters)\n        all_data = {'frequency':self.frequency,'measured':actual,'predicted':predicted}\n\n    elif self.opt_type == 'Dual':\n        no_gap_pred = self._predictionJCA(parameters)[0]\n        gap_pred = self._predictionJCA(parameters)[1]\n        no_gap_actual = self.meas_abs[0]\n        gap_actual = self.meas_abs[1]\n\n        all_data = {'frequency':self.frequency,'no gap measured':no_gap_actual,'no gap predicted':no_gap_pred,'gap measured':gap_actual,'gap predicted':gap_pred}\n\n    with open(file, 'w') as f:\n        [f.write('{0},{1}\\n'.format(key, value)) for key, value in parameters.items()]\n        writer = csv.writer(f, delimiter = \",\",lineterminator='\\n')\n        writer.writerow(all_data.keys())\n        writer.writerows(zip(*all_data.values()))\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.load_to_array","title":"<code>load_to_array(FileName, type='complex')</code>","text":"<p>Loads data from csv or excel file.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.load_to_array--parameters","title":"Parameters","text":"<p>FileName (str):     Name of the file to load data from</p> <p>type (str):     type of data being loaded -- either complex or floating point data</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def load_to_array(self,\n                  FileName: str,\n                  type: str ='complex') -&gt; None:\n    \"\"\"\n    Loads data from csv or excel file.\n\n    Parameters\n    ----------\n    FileName (str):\n        Name of the file to load data from\n\n    type (str):\n        type of data being loaded -- either complex or floating point data\n\n    \"\"\"\n    if type == 'complex':\n        try:\n            data = np.asarray(pd.read_csv(FileName,header=None).map(lambda s: np.complex128(s.replace('i', 'j'))))\n        except Exception:\n            data = np.asarray(pd.read_excel(FileName,header=None).map(lambda s: np.complex128(s.replace('i', 'j'))))\n\n    elif type == 'float':\n        try:\n            data = np.asarray(pd.read_csv(FileName,header=None))\n        except Exception:\n            data = np.asarray(pd.read_excel(FileName,header=None))  \n\n    return (data)\n</code></pre>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.to_database","title":"<code>to_database(parameters, layer_name)</code>","text":"<p>Saves the identified parameters as a new layer in a database.</p>"},{"location":"AcousticID/#src.acoustipy.Params.AcousticID.to_database--parameters","title":"Parameters","text":"<p>parameters (dict):     dictionary containing the identified thickness, flow resistivity, porosity, tortuosity,      viscous characteristic length, thermal characteristic length, and air gap of the sample.</p> <p>layer_name (str):     Specifies the name of the layer.  Must be a unique identifier.</p> Source code in <code>src/acoustipy/Params.py</code> <pre><code>def to_database(self,\n                parameters: dict,\n                layer_name: str) -&gt; None:\n    \"\"\"\n    Saves the identified parameters as a new layer in a database.\n\n    Parameters\n    ----------\n    parameters (dict):\n        dictionary containing the identified thickness, flow resistivity, porosity, tortuosity, \n        viscous characteristic length, thermal characteristic length, and air gap of the sample.\n\n    layer_name (str):\n        Specifies the name of the layer.  Must be a unique identifier.\n    \"\"\"\n\n    thickness = parameters['thickness']\n    flow_resistivity = parameters['flow resistivity']\n    porosity = parameters['porosity']\n    tortuosity = parameters['tortuosity']\n    viscous_characteristic_length = parameters['viscous characteristic length']\n    thermal_characteristic_length = parameters['thermal characteristic length']\n\n    s = AcoustiBase()\n    data = s.pull('LAYER')\n    id1 = len(data)+1\n    params = [id1,layer_name,'identified','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,'null','null','null','null','null','null']\n    s.execute(params,'LAYER')\n    s.commit()\n    s.close()\n</code></pre>"},{"location":"AcousticTMM/","title":"AcousticTMM","text":""},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM","title":"<code>AcousticTMM</code>","text":"<p>Create an AcousticTMM object</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM--description","title":"Description:","text":"<p>AcousticTMM is an implementation of the acoustic transfer matrix method and a number of porous material models built on top of numpy (https://numpy.org/). It can be used to calculate interesting acoustic characteristics -- like the frequency dependent reflection, absorption, and transmission coefficients of a variety of materials.  Using AcousticTMM, a number of layers can be defined and combined to create multilayer structures, which can then be acoustically simulated via the  transfer matrix method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM--attributes","title":"Attributes:","text":"<p>fmin (int):    Minimum frequency of the range of interest</p> <p>fmax (int)::     Maximum frequency of the range of interest</p> <p>fs (int):     Frequency step size; reduce computation time by taking larger strides between frequencies within the range.</p> <p>incidence (str):     'Normal' or 'Diffuse'; Compute properties of interest in impedence tube like conditions or in reverberant conditions.</p> <p>angles (list):     If Diffuse incidence is specified, gives tighter control over the angles used to calculate properties of interest.</p> <p>air_temperature (float):     Temperature of air [\u00b0C].  If specified, all other air properties will be determined by this parameter.</p> <p>sound_speed (float):     Speed of sound in air [m/s]</p> <p>air_density (float):     Density of air [kg/m3]</p> <p>Cp (float):     Specific heat @ constant pressure [kJ/kg K]</p> <p>Cv (float):     Specifc heat @ constant volume [kJ/kg K]</p> <p>viscosity (float):     Dynamic viscosity of air [kg/m*s]</p> <p>Pr (float):     Prandtl number of air []</p> <p>P0 (float):     Atmospheric pressure [Pa]</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>class AcousticTMM():\n    \"\"\"\n    Create an AcousticTMM object\n\n    Description:\n    ------------\n    AcousticTMM is an implementation of the acoustic transfer matrix method and a number of porous material models built on top of numpy (https://numpy.org/).  \n    It can be used to calculate interesting acoustic characteristics -- like the frequency dependent reflection, absorption, and transmission coefficients of a variety of materials. \n    Using AcousticTMM, a number of layers can be defined and combined to create multilayer structures, which can then be acoustically simulated via the \n    transfer matrix method.\n\n    Attributes:\n    -----------\n    fmin (int):\n       Minimum frequency of the range of interest\n\n    fmax (int)::\n        Maximum frequency of the range of interest\n\n    fs (int):\n        Frequency step size; reduce computation time by taking larger strides between frequencies within the range.\n\n    incidence (str):\n        'Normal' or 'Diffuse'; Compute properties of interest in impedence tube like conditions or in reverberant conditions.\n\n    angles (list):\n        If Diffuse incidence is specified, gives tighter control over the angles used to calculate properties of interest.\n\n    air_temperature (float):\n        Temperature of air [\u00b0C].  If specified, all other air properties will be determined by this parameter.\n\n    sound_speed (float):\n        Speed of sound in air [m/s]\n\n    air_density (float):\n        Density of air [kg/m3]\n\n    Cp (float):\n        Specific heat @ constant pressure [kJ/kg K]\n\n    Cv (float):\n        Specifc heat @ constant volume [kJ/kg K]\n\n    viscosity (float):\n        Dynamic viscosity of air [kg/m*s]\n\n    Pr (float):\n        Prandtl number of air []\n\n    P0 (float):\n        Atmospheric pressure [Pa]\n\n    \"\"\"\n\n    def __init__(self,\n                 fmin:int = 4,\n                 fmax:int = 3200,\n                 fs:int = 4,\n                 incidence:str = 'Normal',\n                 angles:list[int] = [0,79,1],\n                 air_temperature:float = None,\n                 sound_speed:float = 343.152,\n                 air_density:float = 1.2058,\n                 Cp:float = 1.004425,\n                 Cv:float = 0.717425,\n                 viscosity:float = 1.825e-05,\n                 Pr:float = .7157,\n                 P0:float = 101325\n                 ):\n\n        #Define limits on the frequency range and angles\n        if fs &lt;= 0:\n            raise ValueError(\"Frequency Step (fs) must be greater than 0!\")\n\n        if fmin &lt;= 0:\n            raise ValueError(\"Minimum frequency (fmin) must be greater than 0!\")\n\n        if fmin &gt;= fmax:\n            raise ValueError(\"Minimum frequency (fmin) must be less than maximum frequency (fmax)!\")\n\n        if angles[0] &gt;= angles[1]:\n            raise ValueError(\"Minimum angle must be less than maximum angle!\")\n\n        if abs(round((angles[1]-angles[0])%angles[2]/angles[2])-((angles[1]-angles[0])%angles[2]/angles[2])) &gt;  1e-6:\n            raise ValueError(\"Angle step size must be a multiple of the angle range!\")\n\n\n        self.temp = air_temperature\n        self.speed = sound_speed\n        self.density = air_density\n        self.fmin = fmin\n        self.fmax = fmax\n        self.fs = fs\n        self.incidence = incidence\n        self.angles = angles\n        self.THIRD_OCTAVE_PREFERRED = np.asarray([16,20,25,31.5,40,50,63,\n                                                  80,100,125,160,200,250,\n                                                  315,400,500,630,800,1000,\n                                                  1250,1600,2000,2500,3150,\n                                                  4000,5000,6300,8000,10000,\n                                                  12500,16000,20000])\n        self.OCTAVE_PREFERRED  = self.THIRD_OCTAVE_PREFERRED[0::3]\n        self.Cp = Cp\n        self.Cv = Cv\n        self.viscosity = viscosity\n        self.Pr = Pr\n        self.P0 = P0\n        self._custom_freq =  np.arange(self.fmin,self.fmax+self.fs,self.fs)\n        self.layers = []\n\n\n    @property\n    def frequency(self):\n        #frequency range of interest\n        return(self._custom_freq)\n\n    @frequency.setter\n    def frequency(self, value):\n        self._custom_freq = value\n\n    @property\n    def ang_freq(self):\n\n        #angular frequency\n        w = 2.0*np.pi*self.frequency\n        return(w)\n\n    @property    \n    def density_temp(self):\n        #Temperature dependent density of air\n        if self.temp is None:\n            airdensity = self.density\n        else:\n            airdensity = ((1.07743*1e-5)*(self.temp**2))+((-0.004581339)*self.temp)+(1.294685259)\n        return (airdensity)\n\n    @property\n    def soundspeed_temp(self):\n        #Temperature dependent speed of sound in air\n        if self.temp is None:\n            soundspeed = self.speed\n        else:\n            soundspeed = (.6016*self.temp)+331.12\n        return(soundspeed)\n\n    @property\n    def gamma_temp(self):\n        #Temperature dependent specific heat ratio\n        if self.temp is None:\n            gamma = self.Cp/self.Cv\n        else:\n            Cp = (4.00166852057851e-07*self.temp**2)+(1.69769187986639e-05*self.temp)+(1.00559293937709)\n            Cv = (3.65205412117683e-07*self.temp**2)+(2.88811127246258e-05*self.temp)+(7.17032243570935e-01)\n            gamma = Cp/Cv\n        return(gamma)\n\n    @property\n    def viscosity_temp(self):\n        #Temperature dependent viscosity of air\n        if self.temp is None:\n            visc = self.viscosity\n            return(visc)\n        else:\n            visc = (-3.52159145081837e-11*self.temp**2)+(4.93272149610679e-8*self.temp)+(1.72293415521214e-5)\n            return(visc)\n\n    @property\n    def Pr_temp(self):\n        #Temperature dependent prandtl number\n        if self.temp is None:\n            Prandtl = self.Pr\n        else:\n            Prandtl = (7.06471476243448e-07*self.temp**2)+(-2.20826446051168e-04*self.temp)+(0.71980868)\n        return(Prandtl)\n\n    @property\n    def k0(self):\n        #Wavenumber\n        k0 = self.ang_freq / self.soundspeed_temp\n        return (k0)\n\n    @property\n    def Z0(self):\n        #Characteristic Impedance of Air\n        z0 = self.density_temp*self.soundspeed_temp\n        return(z0)\n\n\n    def _create_layer_TM(self,\n                         Zp: np.ndarray,\n                         kp: np.ndarray,\n                         thickness: float) -&gt; np.ndarray:\n        \"\"\"\n        Creates the transfer matrix for an individual layer in either normal or diffuse sound fields\n\n        Parameters\n        ----------\n        Zp (ndarray):\n            Characteristic impedance of the layer\n\n        kp (ndarray):\n            Characteristic wavenumber of the layer\n\n        thickness (float):\n            Layer thickness [m]\n\n        Returns\n        -------\n        TM (ndarray):\n            Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix\n            Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix\n\n        \"\"\"\n        if self.incidence == \"Normal\":\n            TM = np.zeros((2,2,len(self.frequency)),dtype = 'complex_')\n            TM[0][0] = np.cos(kp*thickness)\n            TM[0][1] = 1j*Zp*np.sin(kp*thickness)\n            TM[1][0] = (1j/Zp)*np.sin(kp*thickness)\n            TM[1][1] = np.cos(kp*thickness)\n\n            return (TM)\n\n        elif self.incidence == \"Diffuse\":\n            angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n            vs = np.sin(np.radians(angles))\n            TM = np.zeros((2,2,len(self.frequency),len(angles)),dtype = 'complex_')\n            kpx = np.zeros((len(self.frequency),len(angles)),dtype = 'complex_')\n\n            Kp = np.einsum('ij,ij -&gt; ij',np.tile(kp[:,None], (1,len(angles))),np.tile(kp[:,None], (1,len(angles))))\n            K0 = np.einsum('ij,ij -&gt; ij',np.tile(self.k0[:,None],(1,len(angles))),np.tile(self.k0[:,None],(1,len(angles))))\n            VS = np.einsum('ij,ij -&gt; ij',vs[None,:],vs[None,:])\n            kpx[:,:] = np.sqrt((Kp)-(np.einsum('ij,ij -&gt; ij',K0,VS)))\n\n            sin = 1j*np.sin(kpx*thickness)\n            cos = np.cos(kpx*thickness)\n            offset = np.einsum('ij,ij,ij -&gt; ij',Zp[:, None],kp[:, None],1/kpx)\n\n\n            TM[0,0,:,:] = cos\n            TM[0,1,:,:] = np.einsum('ij,ij -&gt; ij',offset,sin)\n            TM[1,0,:,:] = np.einsum('ij,ij -&gt; ij',sin,1/offset)\n            TM[1,1,:,:] = cos\n\n            return(TM)\n\n    def _create_Maa_MPP_TM(self,\n                           Zp: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Creates the transfer matrix for a Maa microperforated panel layer in either normal or diffuse sound fields\n\n        Parameters\n        ----------\n        Zp (ndarray):\n            Characteristic impedance of the layer\n\n        Returns\n        -------\n        TM (ndarray):\n            Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix\n            Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix\n\n        \"\"\"\n        if self.incidence == \"Normal\":\n            TM = np.zeros((2,2,len(self.frequency)),dtype = 'complex_')\n            TM[0][0] = 1\n            TM[0][1] = Zp\n            TM[1][0] = 0\n            TM[1][1] = 1\n\n            return (TM)\n\n        elif self.incidence == \"Diffuse\":\n            angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n\n            TM = np.zeros((2,2,len(self.frequency),len(angles)),dtype = 'complex_')\n\n            count = 0\n            for theta in angles:\n\n                TM[0,0,:,count] = 1\n                TM[0,1,:,count] = Zp*np.cos(np.radians(theta))\n                TM[1,0,:,count] = 0\n                TM[1,1,:,count] = 1\n                count += 1\n\n            return(TM)\n\n    def _calc_dynamics(self,\n                       flow_resistivity: float,\n                       porosity: float,\n                       tortuosity: float,\n                       viscous_characteristic_length: float,\n                       thermal_characteristic_length: float,\n                       thermal_permeability: float,\n                       thermal_tortuosity: float,\n                       viscous_tortuosity: float,\n                       model: str) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Calculates the dynamic mass density and bulk modulus for porous, equivalent fluid models.\n\n        Parameters\n        ----------\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        tortuosity (float):\n            high frequency limit of the tortuosity of the material\n\n        viscous_characteristic_length (float):\n            viscous characteristic length of the material [m]\n\n        thermal_characteristic_length (float):\n            thermal characteristic length of the material [m]\n\n        thermal_permeability (float):\n            static thermal permeability of the material [m2]\n\n        thermal_tortuosity (float):\n            static thermal tortuosity of the material\n\n        viscous_tortuosity (float):\n            static viscous tortuosity of the material\n\n        model (str):\n            defines the equivalent fluid model to be used\n\n\n        Returns\n        -------\n        peff, keff (tuple(ndarray, ndarray)):\n            arrays of shape [len(frequency),1] representing the dynamic mass density\n            and bulk modulus of the material\n\n        \"\"\"\n        fr = flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length\n        tcl = thermal_characteristic_length\n        kprime = thermal_permeability\n        tauprime = thermal_tortuosity\n        tau0 = viscous_tortuosity\n\n        w = self.ang_freq\n\n        if model == 'DB':\n            #Delaney-Bazley Model\n            DB_Param = (self.frequency*self.density_temp)/fr\n\n            a = DB_Param**-.754\n            b = DB_Param**-.732\n            c = DB_Param**-.700\n            d = DB_Param**-.595\n\n            Zr = self.Z0*(1+.0571*a)\n            Zi = self.Z0*.0870*b\n            kr = self.k0*(1+.0978*c)\n            ki = .189*self.k0*d\n\n\n            Zp = Zr-(1j*Zi)\n            kp = kr-(1j*ki)\n\n            peff = (Zp*kp)/w\n            keff = (Zp*w)/kp\n\n        elif model == 'DBM':\n            #Delaney-Bazley-Miki Model\n            DBM_Param = self.frequency/fr\n\n            a = DBM_Param**-.632\n            b = DBM_Param**-.618\n\n            Zr = self.Z0*(1+.0699*a)\n            Zi = self.Z0*.107*a\n            kr = self.k0*(1+.109*b)\n            ki = .160*self.k0*b\n\n            Zp = Zr-(1j*Zi)\n            kp = kr-(1j*ki)\n\n            peff = (Zp*kp)/w\n            keff = (Zp*w)/kp\n\n        elif model == 'JCA':\n            #Johnson-Champoux-Allard Model\n            wp = (w*self.density_temp*tau)/(fr*phi)\n            wpp = ((tcl**2)*self.Pr_temp*self.density_temp*w)/(8*self.viscosity_temp)\n            p=1\n            m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n            pprime = 1\n            mprime = 1\n\n            Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n            aw = tau*(1+(Fw/(1j*wp)))\n\n            Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n            bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n            peff = self.density_temp*aw/phi\n            keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n        elif model == 'JCAL':\n            #Johnson-Champoux-Allard-Lafarge Model\n            wp = (w*self.density_temp*tau)/(fr*phi)\n            wpp = (w*self.density_temp*self.Pr_temp*kprime)/(self.viscosity_temp*phi)\n            p = 1\n            m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n            pprime = 1\n            mprime = (8*kprime)/(phi*(tcl**2))\n\n            Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n            aw = tau*(1+(Fw/(1j*wp)))\n\n            Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n            bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n            peff = self.density_temp*aw/phi\n            keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n        elif model == 'JCAPL':\n            #Johnson-Champoux-Allard-Pride-Lafarge Model\n            wp = (w*self.density_temp*tau)/(fr*phi)\n            wpp = (w*self.density_temp*self.Pr_temp*kprime)/(self.viscosity_temp*phi)\n            m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n            p = m/(4*((tau0/tau)-1))\n            mprime = (8*kprime)/(phi*(tcl**2))\n            pprime = mprime/((4*(tauprime-1)))\n\n            Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n            aw = tau*(1+(Fw/(1j*wp)))\n\n            Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n            bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n            peff = self.density_temp*aw/phi\n            keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n        return (peff,keff)\n\n    def Add_Air_Layer(self,\n                      thickness: float=400,\n                      save_layer: bool = False,\n                      layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define an air gap layer\n\n        Parameters\n        ----------\n        thickness (float):\n            air gap thickness [mm]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'AIR','null',thickness,'null','null','null','null','null','null','null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        Zp = np.full(len(self.frequency),self.Z0)\n        thickness = thickness / 1000\n        TM = self._create_layer_TM(Zp,self.k0,thickness)\n\n        return([TM,0,layer_name])\n\n    def Add_DB_Layer(self,\n                     thickness: float,\n                     flow_resistivity: float,\n                     save_layer: bool = False,\n                     layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Delaney-Bazley Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resistivity (float):\n            static flow resistivity of the layer [Pa*s/m2]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list(ndarray, float, str):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"      \n        if save_layer == True:\n            params = [layer_name,'DB','null',thickness,flow_resistivity,'null','null','null','null','null','null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        dyns = self._calc_dynamics(flow_resistivity, 0, 0, 0, 0, 0, 0, 0, model='DB')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_DBM_Layer(self,\n                      thickness: float,\n                      flow_resistivity: float,\n                      save_layer: bool = False,\n                      layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Delaney-Bazley-Miki Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resistivity (float):\n            static flow resistivity of the layer [Pa*s/m2]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'DBM','null',thickness,flow_resistivity,'null','null','null','null','null','null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        dyns = self._calc_dynamics(flow_resistivity, 0, 0, 0, 0, 0, 0, 0, model='DB')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n\n    def Add_JCA_Layer(self,\n                      thickness: float,\n                      flow_resistivity: float,\n                      porosity: float,\n                      tortuosity: float,\n                      viscous_characteristic_length: float,\n                      thermal_characteristic_length: float,\n                      save_layer: bool = False,\n                      layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Johnson-Champoux-Allard Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        tortuosity (float):\n            high frequency limit of the tortuosity of the material\n\n        viscous_characteristic_length (float):\n            viscous characteristic length of the material [\u00b5m]\n\n        thermal_characteristic_length (float):\n            thermal characteristic length of the material [\u00b5m]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'JCA','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,'null','null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length*(1e-6)\n        tcl = thermal_characteristic_length*(1e-6)\n\n        dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, 0, 0, 0, model='JCA')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_JCAL_Layer(self,\n                       thickness: float,\n                       flow_resistivity: float,\n                       porosity: float,\n                       tortuosity: float,\n                       viscous_characteristic_length: float,\n                       thermal_characteristic_length: float,\n                       thermal_permeability: float,\n                       save_layer: bool = False,\n                       layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Johnson-Champoux-Allard-Lafarge Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        tortuosity (float):\n            high frequency limit of the tortuosity of the material\n\n        viscous_characteristic_length (float):\n            viscous characteristic length of the material [\u00b5m]\n\n        thermal_characteristic_length (float):\n            thermal characteristic length of the material [\u00b5m]\n\n        thermal_permeability (float):\n            static thermal permeability of the material [m2]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'JCAL','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,'null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length*(1e-6)\n        tcl = thermal_characteristic_length*(1e-6)\n        kprime = thermal_permeability*(1e-10)\n\n        dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, 0, 0, model='JCAL')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_JCAPL_Layer(self,\n                        thickness: float,\n                        flow_resistivity: float,\n                        porosity: float,\n                        tortuosity: float,\n                        viscous_characteristic_length: float,\n                        thermal_characteristic_length: float,\n                        thermal_permeability: float,\n                        thermal_tortuosity: float,\n                        viscous_tortuosity: float,\n                        save_layer: bool = False,\n                        layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Johnson-Champoux-Allard-Pride-Lafarge Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        tortuosity (float):\n            high frequency limit of the tortuosity of the material\n\n        viscous_characteristic_length (float):\n            viscous characteristic length of the material [\u00b5m]\n\n        thermal_characteristic_length (float):\n            thermal characteristic length of the material [\u00b5m]\n\n        thermal_permeability (float):\n            static thermal permeability of the material [m2]\n\n        thermal_tortuosity (float):\n            static thermal tortuosity of the material\n\n        viscous_tortuosity (float):\n            static viscous tortuosity of the material\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'JCAPL','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,'null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = self.viscosity_temp/flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length*(1e-6)\n        tcl = thermal_characteristic_length*(1e-6)\n        kprime = thermal_permeability*(1e-10)\n        tauprime = thermal_tortuosity\n        tau0 = viscous_tortuosity\n\n        dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model='JCAPL')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_Horoshenkov_Layer(self,\n                              thickness: float,\n                              porosity: float,\n                              median_pore_size: float,\n                              pore_size_distribution: float,\n                              save_layer: bool = False,\n                              layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a layer using the Horoshenkov et al Model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        porosity (float):\n            open porosity of the material\n\n        median_pore_size (float):\n            median pore size of the material [\u00b5m]\n\n        pore_size_distribution (float):\n            standard deviation in the pore size distribution\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'horoshenkov','null',thickness,'null',porosity,'null','null','null','null','null','null','null','null','null',median_pore_size,pore_size_distribution]\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n        mps = median_pore_size*(1e-6)\n        psd = pore_size_distribution\n        phi = porosity\n\n        X = (psd*np.log(2))**2\n        tau = np.exp(4*X)\n        Z = phi*(mps**2)/(8*tau)\n\n\n        fr = (self.viscosity_temp/Z)*np.exp(6*X)\n        vcl = mps*np.exp((-5/2)*X)\n        tcl = mps*np.exp((3/2)*X)\n        kprime = Z/np.exp(-6*X)\n\n        dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, 0, 0, model='JCAL')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_Biot_Limp_Layer(self,\n                            EF_model: str,\n                            thickness: float,\n                            flow_resistivity: float,\n                            mass_density: float,\n                            porosity: float,\n                            tortuosity: float=0,\n                            viscous_characteristic_length: float=0,\n                            thermal_characteristic_length: float=0,\n                            thermal_permeability: float=0,\n                            thermal_tortuosity: float=0,\n                            viscous_tortuosity: float=0,\n                            save_layer: bool = False,\n                            layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n        \"\"\"\n        Define a limp Biot layer, using any of the equivalent fluid models\n\n        Parameters\n        ----------\n        EF_model (str):\n            Equivalent fluid model to be used:\n            DB --&gt; Delaney-Bazley\n            DBM --&gt; Delaney-Bazley-Miki\n            JCA --&gt; Johnson-Champoux-Allard\n            JCAL --&gt; Johnson-Champoux-Allar-Lafarge\n            JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge\n\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        mass_density (float):\n            bulk density of the material [kg/m3]\n\n        tortuosity (float):, optional\n            high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.\n\n        viscous_characteristic_length (float):, optional\n            viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.\n\n        thermal_characteristic_length (float):, optional\n            thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.\n\n        thermal_permeability (float):, optional\n            static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.\n\n        thermal_tortuosity (float):, optional\n            static thermal tortuosity of the material. Needed for JCAPL models.\n\n        viscous_tortuosity (float):, optional\n            static viscous tortuosity of the material. Needed for JCAPL models.\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'biot_limp',EF_model,thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,mass_density,'null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length*(1e-6)\n        tcl = thermal_characteristic_length*(1e-6)\n        kprime = thermal_permeability*(1e-10)\n        tauprime = thermal_tortuosity\n        tau0 = viscous_tortuosity\n\n        if EF_model == 'JCA':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'JCAL':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'JCAPL':\n            fr = self.viscosity_temp/fr\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'DB':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'DBM':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        rho_tilde = mass_density+(phi*self.density_temp)-((self.density_temp**2)/peff)       ##eq. 15\n\n        gamma_tilde = (self.density_temp/peff)-1     #eq. 16\n\n        rho_eq_limp = (1/(phi*peff)) + ((gamma_tilde**2)/(phi*rho_tilde))    #eq. 24\n\n        rho_eq_limp = 1/rho_eq_limp\n\n        Zp = np.sqrt(rho_eq_limp*keff)\n        kp = self.ang_freq*np.sqrt(rho_eq_limp/keff)\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_Biot_Rigid_Layer(self,\n                             EF_model: str,\n                             thickness: float,\n                             flow_resistivity: float,\n                             mass_density: float,\n                             porosity: float,\n                             tortuosity: float=0,\n                             viscous_characteristic_length: float=0,\n                             thermal_characteristic_length: float=0,\n                             thermal_permeability: float=0,\n                             thermal_tortuosity: float=0,\n                             viscous_tortuosity: float=0,\n                             save_layer: bool = False,\n                             layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n        \"\"\"\n        Define a rigid Biot layer, using any of the equivalent fluid models\n\n        Parameters\n        ----------\n        EF_model (str):\n            Equivalent fluid model to be used:\n            DB --&gt; Delaney-Bazley\n            DBM --&gt; Delaney-Bazley-Miki\n            JCA --&gt; Johnson-Champoux-Allard\n            JCAL --&gt; Johnson-Champoux-Allar-Lafarge\n            JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge\n\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        mass_density (float):\n            bulk density of the material [kg/m3]\n\n        tortuosity (float):, optional\n            high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.\n\n        viscous_characteristic_length (float):, optional\n            viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.\n\n        thermal_characteristic_length (float):, optional\n            thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.\n\n        thermal_permeability (float):, optional\n            static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.\n\n        thermal_tortuosity (float):, optional\n            static thermal tortuosity of the material. Needed for JCAPL models.\n\n        viscous_tortuosity (float):, optional\n            static viscous tortuosity of the material. Needed for JCAPL models.\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'biot_rigid',EF_model,thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,mass_density,'null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = flow_resistivity\n        tau = tortuosity\n        phi = porosity\n        vcl = viscous_characteristic_length*(1e-6)\n        tcl = thermal_characteristic_length*(1e-6)\n        kprime = thermal_permeability*(1e-10)\n        tauprime = thermal_tortuosity\n        tau0 = viscous_tortuosity\n\n\n        if EF_model == 'JCA':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'JCAL':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'JCAPL':\n            fr = self.viscosity_temp/fr\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'DB':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n        elif EF_model == 'DBM':\n            peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n\n        rho_tilde = mass_density+(phi*self.density_temp)-((self.density_temp**2)/peff)   #eq. 15\n\n        gamma_tilde = (self.density_temp/peff)-1     #e. 16\n\n        rho_eq_limp = (1/(phi*peff)) + ((gamma_tilde**2)/(phi*rho_tilde)) + (((1-phi)/phi)*(gamma_tilde/rho_tilde))  #eq. 23\n\n        rho_eq_limp = 1/rho_eq_limp\n\n        Zp = np.sqrt(rho_eq_limp*keff)\n        kp = self.ang_freq*np.sqrt(rho_eq_limp/keff)\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n\n    def Add_Resistive_Screen(self,\n                             thickness: float,\n                             flow_resistivity: float,\n                             porosity: float,\n                             save_layer: bool = False,\n                             layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n\n\n        \"\"\"\n        Define a resistive screen layer\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        flow_resisitivty (float):\n            Static air flow resistivity of the material [Pa*s/m2]\n\n        porosity (float):\n            open porosity of the material\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'screen','null',thickness,flow_resistivity,porosity,'null','null','null','null','null','null','null','null','null','null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        fr = flow_resistivity\n        phi = porosity\n\n        w = self.ang_freq\n\n        keff = self.P0/phi\n        peff = ((self.density_temp/phi)+(fr/(1j*w)))\n\n        Zp = np.sqrt(peff*keff)\n        kp = self.ang_freq*np.sqrt(peff/keff)\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_MAA_MPP_Layer(self,\n                          thickness: float,\n                          pore_diameter: float,\n                          c_to_c_dist: float,\n                          save_layer: bool = False,\n                          layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n        \"\"\"\n        Define a microperforated layer using Maa's model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        pore_diameter (float):\n            diameter of the microperforate [mm]\n\n        c_to_c_dist (float):\n            center to center distance of the microperforates [mm]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'MAA_MPP','null',thickness,'null','null','null','null','null','null','null','null','null',pore_diameter,c_to_c_dist,'null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        d = pore_diameter/1000\n        b = c_to_c_dist/1000\n\n        w = self.ang_freq\n\n        x = d*np.sqrt((w*self.density_temp)/(4*self.viscosity_temp))\n        phi = (np.pi/4)*((d/b)**2)\n\n        x = d/2*np.sqrt(w*self.density_temp/(self.viscosity_temp))\n        r1 = np.sqrt(1+x**2/32)+np.sqrt(2)/32*x*d/thickness\n        r = 32*self.viscosity_temp/phi*thickness/d**2*r1\n        m1 = 1+1/np.sqrt(1+x**2/2)+0.85*d/thickness\n        m = self.density_temp*thickness/phi*m1\n\n        Zp = (r+(1j*w*m))\n\n        TM = self._create_Maa_MPP_TM(Zp)\n\n        return([TM,thickness,layer_name])\n\n    def Add_MPP_EF_Layer(self,\n                         thickness: float,\n                         pore_diameter: float,\n                         c_to_c_dist: float,\n                         save_layer: bool = False,\n                         layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n        \"\"\"\n        Define a microperforated layer using an equivalent fluid model\n\n        Parameters\n        ----------\n        thickness (float):\n            layer thickness [mm]\n\n        pore_diameter (float):\n            diameter of the microperforate [mm]\n\n        c_to_c_dist (float):\n            center to center distance of the microperforates [mm]\n\n        save_layer (bool):\n            Specify whether to save the input parameters to a database for later use.\n\n        layer_name (str):\n            If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        if save_layer == True:\n            params = [layer_name,'EF_MPP','null',thickness,'null','null','null','null','null','null','null','null','null',pore_diameter,c_to_c_dist,'null','null']\n            self._layer_to_db(params)\n\n        thickness = thickness/1000\n\n        d = pore_diameter/1000\n        b = c_to_c_dist/1000\n\n        phi = (np.pi/4)*((d/b)**2)\n\n        eps = 2.0*np.sqrt(phi/np.pi)\n        fok = (1-(1.13*eps)-(0.09*(eps**2))+(0.27*(eps**3)))*(4*d/3*np.pi)\n        fr = (32*self.viscosity_temp)/(phi*(d**2))\n\n        vcl = d/2\n        tcl = d/2\n\n        tau = 1+(2*fok/thickness)\n\n        dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, 0, 0, 0, model='JCA')\n\n        Zp = np.sqrt(dyns[0]*dyns[1])\n        kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        return([TM,thickness,layer_name])\n\n    def Add_Layer_From_Tube(self,\n                            no_gap_file: str,\n                            gap_file: str,\n                            sample_thickness: float,\n                            air_gap_thickness: float,\n                            measurement: str = 'reflection') -&gt; list[np.ndarray, float, str]:\n\n\n\n        \"\"\"\n        Define a layer from the normal incidence reflection coefficients or the surface impedance of a material obtained from\n        an impedance tube.  Utsuno's method currently implemented.\n\n        Parameters\n        ----------\n        no_gap_file (str):\n            Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained \n            from an impedence tube measurement with rigid backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and \n            coefficients in the 2nd.\n\n        gap_file (str):\n            Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained \n            from an impedence tube measurement with an air gap backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and \n            coefficients in the 2nd.\n\n        sample_thickness (float):\n            thickness of the sample [mm]\n\n        air_gap_thickness (float):\n            thickness of the air gap [mm] in the gap mounting condition.\n\n        measurement (str):\n            'reflection' or 'surface' measurement types used in the No_Gap and Gap parameters.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n\n        \"\"\"\n        thickness = sample_thickness/1000\n        air_thickness = air_gap_thickness/1000\n\n\n        no_gap_data = self.load_to_array(no_gap_file)\n        gap_data = self.load_to_array(gap_file)\n\n        if measurement == 'surface':\n            Zs_NG = no_gap_data[:,1]\n            Zs_G = gap_data[:,1]\n\n        elif measurement == 'reflection':\n            Zs_NG = self.Z0*((1+no_gap_data[:,1])/(1-no_gap_data[:,1]))\n            Zs_G = self.Z0*((1+gap_data[:,1])/(1-gap_data[:,1]))\n\n        if np.array_equal(no_gap_data[:,0],gap_data[:,0]) != True:\n            raise ValueError(\"Frequencies must match between no gap and gap curves\")\n\n        T11A = np.cos(self.k0*air_thickness)\n        T21A = (1j/self.Z0)*np.sin(self.k0*air_thickness)\n        Zs_A = T11A/T21A\n\n        Zp = np.sqrt((Zs_G*(Zs_NG+Zs_A))-(Zs_NG*Zs_A))\n        kp = np.arctan(Zp/(1j*Zs_NG))/thickness\n\n        TM = self._create_layer_TM(Zp,kp,thickness)\n\n        for n in range(1,10):\n            rhs = int((n*self.soundspeed_temp)/(2*air_thickness))\n            if rhs &lt; self.fmax:\n                print(f\"Caution: results near {rhs} Hz may be unreliable due to air gap selection!\")\n\n        return([TM,thickness,None]) \n\n    def Add_Layer_From_Database(self,\n                                layer_name: str) -&gt; list[np.ndarray, float, str]:\n\n        '''\n        Define a layer from properties that have been saved to a database.\n\n        Parameters\n        ----------\n        layer_name (str):\n            The unique name the layer was saved to the database as.\n\n        Returns\n        -------\n        TM, thickness, layer_name (list[ndarray, float, str]):\n            The transfer matrix, thickness, and name of the layer.\n        '''\n\n        s = AcoustiBase()\n\n        data = s.query(\"SELECT * from LAYER WHERE name = ?\", (layer_name,))\n        model_type = data[0][2]\n\n        if model_type == 'DB':\n            layer = self.Add_DB_Layer(data[0][4], data[0][5])\n            return(layer)\n\n        elif model_type == 'DBM':\n            layer = self.Add_DBM_Layer(data[0][4], data[0][5])\n            return(layer)\n\n        elif model_type == 'JCA':\n            layer = self.Add_JCA_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9])\n            return(layer)\n\n        elif model_type == 'JCAL':\n            layer = self.Add_JCAL_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10])\n            return(layer)\n\n        elif model_type == 'JCAPL':\n            layer = self.Add_JCAPL_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11],data[0][12])\n            return(layer)\n\n        elif model_type == 'horoshenkov':\n            layer = self.Add_Horoshenkov_Layer(data[0][4],data[0][6],data[0][16],data[0][17])\n            return(layer)\n\n        elif model_type == 'biot_rigid':\n            layer = self.Add_Biot_Rigid_Layer(data[0][3],data[0][4], data[0][5], data[0][13], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11], data[0][12])\n            return(layer)\n\n        elif model_type == 'biot_limp':\n            layer = self.Add_Biot_Limp_Layer(data[0][3],data[0][4], data[0][5], data[0][13], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11], data[0][12])\n            return(layer)\n\n        elif model_type == 'screen':\n            layer = self.Add_Resistive_Screen(data[0][4], data[0][5], data[0][6])\n            return(layer)\n\n        elif model_type == 'MAA_MPP':\n            layer = self.Add_MAA_MPP_Layer(data[0][4], data[0][14], data[0][15])\n            return(layer)\n\n        elif model_type == 'EF_MPP':\n            layer = self.Add_MPP_EF_Layer(data[0][4], data[0][14], data[0][15])\n            return(layer)\n\n        elif model_type == 'identified':\n            layer = self.Add_JCA_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9])\n            return(layer)\n\n        elif model_type == 'AIR':\n            layer = self.Add_Air_Layer(data[0][4])\n            return(layer)\n\n    def assemble_from_database(self,\n                               name: str) -&gt; list[np.ndarray, float]:\n        '''\n        Define a multilayer structure that has been saved to a database.\n\n        Parameters\n        ----------\n        name (str):\n            The unique name the multilayer structure was saved to the database as.\n\n        Returns\n        -------\n        Tt,thickness (list[ndarray, float]):\n            The total transfer matrix and total thickness of the structure.\n        '''\n        s = AcoustiBase()\n\n        data = s.query(\"SELECT * from STRUCTURE WHERE structure_name = ?\", (name,))[0]\n        data = data[2:]\n\n        layers = []\n\n        for d in data:\n            if d != 'null':\n                layers.append(self.Add_Layer_From_Database(d))\n\n        structure = self.assemble_structure(layers,db_flag=True)\n\n        return(structure)\n\n    def assemble_structure(self,\n                           *kwargs,\n                           save_structure: bool=False,\n                           structure_name: str=None,\n                           db_flag: bool=False) -&gt; list[np.ndarray, float]:\n        \"\"\"\n        Calculates the total transfer matrix for a structure of 'n' number of layers.  The structure is defined from left to right --&gt; left being the face\n        of the structure where sound impinges on the surface and right being the back or bottom of the structure that sound propagates through.\n\n        Parameters\n        ----------\n        *kwargs (list):\n            individual transfer matrices, thicknesses, and names of each layer, which is returned by any of the \"Add_XXX_Layer\" methods.\n\n        save_structure (bool):\n            Specify whether to save the structure to a database for later use.\n\n        structure_name (str):\n            If save_structure is set to True, specify the name of the structure.  Must be a unique identifier.\n\n        db_flag (bool):\n            DO NOT CHANGE THIS PARAMETER -- for internal calclations only.\n\n        Returns\n        -------\n        Tt,thickness list([ndarray, float]):\n            The total transfer matrix and total thickness of the structure.\n\n        \"\"\"\n\n        transfer_matrices = []\n        layer_thickness = []\n        layer_names = []\n\n        if db_flag == True:\n            for i in range(len(kwargs[0])):\n                transfer_matrices.append(kwargs[0][i][0])\n                layer_thickness.append(kwargs[0][i][1])\n                layer_names.append(kwargs[0][i][2])\n\n\n        else:\n            for kwarg in kwargs:\n                transfer_matrices.append(kwarg[0])\n                layer_thickness.append(kwarg[1])\n                layer_names.append(kwarg[2])\n\n\n        if save_structure == True:\n            s = AcoustiBase()\n            data = s.pull('STRUCTURE')\n            id1 = len(data)+1\n            param_base = [id1,structure_name]\n            for layer in layer_names:\n                param_base.append(layer)\n\n            params = param_base.copy()\n            for i in range(18-len(param_base)):\n                params.append('null')\n            s.execute(params,'STRUCTURE')\n            s.commit()\n            s.close()\n\n        thickness = sum(layer_thickness)\n        if self.incidence == 'Normal':\n\n            if len(transfer_matrices) == 1:\n                Tt = transfer_matrices[0]\n                return([Tt,thickness])\n\n            elif len(transfer_matrices) &gt; 1:\n                Tt = np.einsum('ijn,jkn-&gt;ikn', transfer_matrices[0], transfer_matrices[1])\n                for i in range(len(transfer_matrices)-2):\n                    Tt = np.einsum('ijn,jkn-&gt;ikn', Tt, transfer_matrices[i+2])\n\n                return([Tt,thickness])\n\n            elif len(transfer_matrices) == 0:\n                raise ValueError(\"Error: Structure Not Defined. Specify each layer in assemble_structure.\")\n\n        elif self.incidence == \"Diffuse\":\n\n            if len(transfer_matrices) == 1:\n                Tt = transfer_matrices[0]\n                return([Tt,thickness])\n\n            elif len(transfer_matrices) &gt; 1:\n                Tt = np.einsum('ijnm,jknm-&gt;iknm', transfer_matrices[0], transfer_matrices[1])\n                for i in range(len(transfer_matrices)-2):\n                    Tt = np.einsum('ijnm,jknm-&gt;iknm', Tt, transfer_matrices[i+2])\n\n                return([Tt,thickness])\n\n            elif len(transfer_matrices) == 0:\n                raise ValueError(\"Error: Structure Not Defined. Specify each layer in assemble_structure.\")\n\n    def reflection(self,\n                   transfer_matrix: list) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the frequency dependent reflection coefficients of the structure.\n\n        Parameters\n        ----------\n        transfer_matrix (list):\n            total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n        Returns\n        -------\n        curve (ndarray):\n            The 2D array of frequencies and reflection coefficients\n\n        \"\"\"\n        Tt = transfer_matrix[0]\n\n        if self.incidence == 'Normal':\n            Zst = Tt[0][0] / Tt[1][0]\n\n            R = (Zst-self.Z0)/(Zst+self.Z0)\n\n            curve = np.column_stack((self.frequency,R))\n            return (curve)\n\n        elif self.incidence == \"Diffuse\":\n\n            angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n            v = np.cos(np.radians(angles))\n\n            Zst = Tt[0][0][:][:]/ Tt[1][0][:][:]\n            r = ((Zst*v)-self.Z0)/((Zst*v)+self.Z0)\n\n            thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n            num = np.sum(r*thetas,1)\n            denom = sum(thetas)\n\n            R = num/denom\n\n            curve = np.column_stack((self.frequency,R))\n            return (curve)\n\n    def absorption(self,\n                   transfer_matrix: list) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the frequency dependent absorption coefficients of the structure.\n\n        Parameters\n        ----------\n        transfer_matrix (list):\n            total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n        Returns\n        -------\n        curve (ndarray):\n            The 2D array of frequencies and absorption coefficients\n\n        \"\"\"\n        Tt = transfer_matrix[0]\n\n        if self.incidence == 'Normal':\n            Zst = Tt[0][0] / Tt[1][0]\n\n            R = (Zst-self.Z0)/(Zst+self.Z0)\n\n            A = 1-abs(R)**2\n            curve = np.column_stack((self.frequency,A))\n\n            return (curve)\n\n        elif self.incidence == \"Diffuse\":\n\n            angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n            v = np.cos(np.radians(angles))\n\n            Zst = Tt[0][0][:][:]/ Tt[1][0][:][:]\n            R = ((Zst*v)-self.Z0)/((Zst*v)+self.Z0)\n\n            a = 1-abs(R)**2\n\n            thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n            num = np.sum(a*thetas,1)\n            denom = sum(thetas)\n\n            A = num/denom\n            curve = np.column_stack((self.frequency,A))\n\n            return (curve)\n\n    def transmission_loss(self,\n                          transfer_matrix: list) -&gt; np.ndarray:\n        \"\"\"\n        Calculates the frequency dependent transmission coefficients of the structure.\n\n        Parameters\n        ----------\n        transfer_matrix (list):\n            total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n        Returns\n        -------\n        curve (ndarray):\n            The 2D array of frequencies and transmission coefficients\n\n        \"\"\"\n        Tt = transfer_matrix[0]\n        thickness = transfer_matrix[1]\n\n        if self.incidence == 'Normal':\n\n            T = (2.0*np.exp(1j*self.k0*thickness))/(Tt[0][0]+(Tt[0][1]/self.Z0)+(self.Z0*Tt[1][0])+Tt[1][1])\n            Te = abs(T)**2\n            TL = 10*np.log10(1/Te)\n\n\n            curve = np.column_stack((self.frequency,TL))\n            return (curve)\n\n        elif self.incidence == \"Diffuse\":\n\n            angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n            v = np.cos(np.radians(angles))\n\n            t1 = 2.0*np.exp(1j*self.k0*thickness)\n            t1 = np.tile(t1,(int((self.angles[1]-self.angles[0])/self.angles[2]),1)).T\n            t2 = (Tt[0][0][:][:]+(Tt[0][1][:][:]*v/self.Z0)+(self.Z0*Tt[1][0][:][:]/v)+Tt[1][1][:][:])\n            T = t1/t2 \n            Te = abs(T)**2\n\n\n            thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n            num = np.sum(Te*thetas,1)\n            denom = sum(thetas)\n\n            Tz = num/denom\n            TL = 10*np.log10(1/Tz)\n\n            curve = np.column_stack((self.frequency,TL))\n\n            return (curve)\n\n    def octave_bands(self,\n                     curve: np.ndarray,\n                     kind: str='THIRD_OCTAVE') -&gt; np.ndarray:\n        \"\"\"\n        Calculates the third octave or octave band absorption or transmission spectrums\n\n        Parameters\n        ----------\n        curve (ndarray):\n            The 2D array of frequencies and absorption or transmission coefficients, which is returend by the 'absorption' or 'transmission_loss' methods.\n\n        kind (str):\n            'OCTAVE' or 'THIRD_OCTAVE'\n\n        Returns\n        -------\n        octaves (ndarray):\n            The 2D array of octave bands and absorption or transmission coefficients\n\n        \"\"\"\n        if kind == 'OCTAVE':\n\n            fl = self.frequency[0]\n            fu = self.frequency[-1]\n\n            mid2 = 1000\n            spec_mid = []  \n            for i in range(int(len(self.OCTAVE_PREFERRED)/2)+1):\n                mid2 = mid2/(2**(1))\n\n            spec_mid = [mid2] \n            for i in range(int(len(self.OCTAVE_PREFERRED))-1):\n                mid2 = mid2*(2**(1))\n                spec_mid.append(mid2)\n\n            spec_mid = np.asarray(spec_mid)\n\n            bands = np.column_stack((self.OCTAVE_PREFERRED,spec_mid))\n\n            lower = []\n            upper = []\n            for n in bands[:,1]:\n                lower.append(n/((2**(1/2))**(1/1)))\n                upper.append(n*((2**(1/2))**(1/1)))\n\n            lower = np.asarray(lower)\n            upper = np.asarray(upper)\n\n            bands = np.column_stack((bands,lower))\n            bands = np.column_stack((bands,upper))\n\n            bands = bands[np.where((bands[:,2] &gt; fl) &amp; (bands[:,2] &lt; fu))]\n\n            octave_abs = []\n            for i in range(len(bands)):    \n                curve_range = curve[np.where((curve[:,0]&gt;=bands[i,2]) &amp; (curve[:,0]&lt;=bands[i,3]))]\n                ave = np.mean(curve_range[:,1])\n                octave_abs.append(ave)\n\n            octaves = np.column_stack((bands[:,0],octave_abs))\n            octaves = octaves[~np.isnan(octaves).any(axis=1)]\n\n            return(octaves)\n\n        elif kind == 'THIRD_OCTAVE':\n\n            fl = self.frequency[0]\n            fu = self.frequency[-1]\n\n            mid2 = 1000\n            spec_mid = []  \n            for i in range(int(len(self.THIRD_OCTAVE_PREFERRED)/2)+2):\n                mid2 = mid2/(2**(1/3))\n\n            spec_mid = [mid2] \n            for i in range(int(len(self.THIRD_OCTAVE_PREFERRED))-1):\n                mid2 = mid2*(2**(1/3))\n                spec_mid.append(mid2)\n\n            spec_mid = np.asarray(spec_mid)\n\n            bands = np.column_stack((self.THIRD_OCTAVE_PREFERRED,spec_mid))\n\n            lower = []\n            upper = []\n            for n in bands[:,1]:\n                lower.append(n/((2**(1/2))**(1/3)))\n                upper.append(n*((2**(1/2))**(1/3)))\n\n            lower = np.asarray(lower)\n            upper = np.asarray(upper)\n\n            bands = np.column_stack((bands,lower))\n            bands = np.column_stack((bands,upper))\n\n            bands = bands[np.where((bands[:,2] &gt; fl) &amp; (bands[:,2] &lt; fu))]\n\n            octave_abs = []\n            for i in range(len(bands)):    \n                curve_range = curve[np.where((curve[:,0]&gt;=bands[i,2]) &amp; (curve[:,0]&lt;=bands[i,3]))]\n                ave = np.mean(curve_range[:,1])\n                octave_abs.append(ave)\n\n            octaves = np.column_stack((bands[:,0],octave_abs))\n            octaves = octaves[~np.isnan(octaves).any(axis=1)]\n\n            return(octaves)\n\n    def SAA(self,\n            third_octave_curve: np.ndarray) -&gt; float:\n        \"\"\"\n        Calculates the average sound absorption coefficient between the 200Hz and 2500Hz third octave frequency bands.  \n\n        Parameters\n        ----------\n        third_octave_curve (ndarray):\n            The 2D array of frequencies and absorption, which is returend by the 'octave_bands' method.\n\n        Returns\n        -------\n        saa (float):\n            The average sound absorption coefficient, rounded to 3 decimal places\n\n        \"\"\"\n        try:\n            l = int(np.where((third_octave_curve[:,0] == 200))[0].item())\n            u = int(np.where((third_octave_curve[:,0] == 2500))[0].item()+1)\n\n            saa = third_octave_curve[l:u,:]\n            saa = round(np.mean(saa[:,1]),3)\n        except TypeError:\n            raise ValueError('Unable to Calculate SAA with given frequency range!')\n            return\n\n        return(saa)\n\n    def FFA(self,\n            third_octave_curve: np.ndarray) -&gt; float:\n        \"\"\"\n        Calculates the four frequency average sound absorption coefficient at the 250Hz, 500Hz, 1000Hz, and 2000Hz third octave frequency bands.  \n\n        Parameters\n        ----------\n        third_octave_curve (ndarray):\n            The 2D array of frequencies and absorption, which is returned by the 'octave_bands' method.\n\n        Returns\n        -------\n        ffa (float):\n            The four frequency average sound absorption coefficient, rounded to 3 decimal places\n\n        \"\"\"\n        absfreq = []\n        for i in (250,500,1000,2000):\n            try:\n                position = int(np.where((third_octave_curve[:,0] == i))[0].item())\n                absorption = third_octave_curve[position,1]\n                absfreq.append(absorption)\n            except TypeError:\n                raise ValueError('Unable to Calculate FFA with given frequency range!')\n                return\n\n        ffa = round(sum(absfreq)/4,3)\n\n        return(ffa)\n\n    def plot_curve(self,\n                   curves: list,\n                   labels: list = None,\n                   kind: str ='LINEAR') -&gt; None:\n        \"\"\"\n        Plots the frequency dependent reflection, absorption, or transmission coefficients of 1 or more structures.\n\n        Parameters\n        ----------\n        curves (list):\n            List of 2D arrays of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',\n            'absorption', or 'transmission_loss' methods.\n\n        labels (list):, optional\n            List of strings to create a legend on the plot with labels\n\n        kind (str):\n            'LINEAR' or 'LOG' --&gt; define whether the frequencies should be converted to a log scale for plotting purposes.\n\n        \"\"\"\n        f, ax = plt.subplots(1)\n\n        if kind == 'LINEAR':\n            i=0\n            for curve in curves:\n                if labels is not None:\n                    ax.plot(curve[:,0],curve[:,1],label=labels[i])\n                    ax.legend(loc=\"lower right\")\n                    i+=1\n                else:\n                   ax.plot(curve[:,0],curve[:,1]) \n\n            ax.set_ylim(bottom=0)\n            plt.show()\n\n\n        elif kind == 'LOG':\n            i=0\n            for curve in curves:\n                if labels is not None:\n                    logfreq = np.log10(curve[:,0])\n                    ax.plot(logfreq,curve[:,1],label=labels[i])\n                    ax.legend(loc=\"lower right\")\n                    i+=1\n                else:\n                    logfreq = np.log10(curve[:,0])\n                    ax.plot(logfreq,curve[:,1])\n\n\n            ax.set_ylim(bottom=0)\n            plt.show()\n\n        return\n\n    def to_csv(self,\n               filename: str,\n               data: np.ndarray) -&gt; None:\n        \"\"\"\n        Saves the frequency dependent reflection, absorption, or transmission coefficients of a structure to a csv file without headers.\n\n        Parameters\n        ----------\n\n        filename (str):\n            Name of the csv file to save data to\n\n        data (ndarray):\n            2D array of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',\n            'absorption', or 'transmission_loss' methods\n\n        \"\"\"\n        if \".csv\" in filename:\n            file = filename\n        else:\n            file = filename+\".csv\"\n\n        save_path = os.path.join(file)\n        np.savetxt(save_path, data, delimiter=\",\")\n\n    def load_to_array(self,\n                      filename: str,\n                      type: str ='complex') -&gt; None:\n        \"\"\"\n        Loads data from csv or excel file.\n\n        Parameters\n        ----------\n        filename (str):\n            Name of the file to load data from\n\n        type (str):\n            type of data being loaded -- either complex or floating point data\n\n        \"\"\"\n        if type == 'complex':\n            try:\n                data = np.asarray(pd.read_csv(filename,header=None).applymap(lambda s: np.complex128(s.replace('i', 'j'))))\n            except Exception:\n                data = np.asarray(pd.read_excel(filename,header=None).applymap(lambda s: np.complex128(s.replace('i', 'j'))))\n\n        elif type == 'float':\n            try:\n                data = np.asarray(pd.read_csv(filename,header=None))\n            except Exception:\n                data = np.asarray(pd.read_excel(filename,header=None))  \n\n        return (data)\n\n    def _layer_to_db(self,\n                    params: list) -&gt; None:\n            '''\n            Add a layer to the database\n\n            Parameters\n            ----------\n            params (list):\n                Attributes of the given layer\n\n            '''\n            s = AcoustiBase()\n            data = s.pull('LAYER')\n            id1 = len(data)+1\n            params.insert(0,id1)\n            s.execute(params,'LAYER')\n            s.commit()\n            s.close()\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_layer_TM","title":"<code>_create_layer_TM(Zp, kp, thickness)</code>","text":"<p>Creates the transfer matrix for an individual layer in either normal or diffuse sound fields</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_layer_TM--parameters","title":"Parameters","text":"<p>Zp (ndarray):     Characteristic impedance of the layer</p> <p>kp (ndarray):     Characteristic wavenumber of the layer</p> <p>thickness (float):     Layer thickness [m]</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_layer_TM--returns","title":"Returns","text":"<p>TM (ndarray):     Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix     Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def _create_layer_TM(self,\n                     Zp: np.ndarray,\n                     kp: np.ndarray,\n                     thickness: float) -&gt; np.ndarray:\n    \"\"\"\n    Creates the transfer matrix for an individual layer in either normal or diffuse sound fields\n\n    Parameters\n    ----------\n    Zp (ndarray):\n        Characteristic impedance of the layer\n\n    kp (ndarray):\n        Characteristic wavenumber of the layer\n\n    thickness (float):\n        Layer thickness [m]\n\n    Returns\n    -------\n    TM (ndarray):\n        Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix\n        Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix\n\n    \"\"\"\n    if self.incidence == \"Normal\":\n        TM = np.zeros((2,2,len(self.frequency)),dtype = 'complex_')\n        TM[0][0] = np.cos(kp*thickness)\n        TM[0][1] = 1j*Zp*np.sin(kp*thickness)\n        TM[1][0] = (1j/Zp)*np.sin(kp*thickness)\n        TM[1][1] = np.cos(kp*thickness)\n\n        return (TM)\n\n    elif self.incidence == \"Diffuse\":\n        angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n        vs = np.sin(np.radians(angles))\n        TM = np.zeros((2,2,len(self.frequency),len(angles)),dtype = 'complex_')\n        kpx = np.zeros((len(self.frequency),len(angles)),dtype = 'complex_')\n\n        Kp = np.einsum('ij,ij -&gt; ij',np.tile(kp[:,None], (1,len(angles))),np.tile(kp[:,None], (1,len(angles))))\n        K0 = np.einsum('ij,ij -&gt; ij',np.tile(self.k0[:,None],(1,len(angles))),np.tile(self.k0[:,None],(1,len(angles))))\n        VS = np.einsum('ij,ij -&gt; ij',vs[None,:],vs[None,:])\n        kpx[:,:] = np.sqrt((Kp)-(np.einsum('ij,ij -&gt; ij',K0,VS)))\n\n        sin = 1j*np.sin(kpx*thickness)\n        cos = np.cos(kpx*thickness)\n        offset = np.einsum('ij,ij,ij -&gt; ij',Zp[:, None],kp[:, None],1/kpx)\n\n\n        TM[0,0,:,:] = cos\n        TM[0,1,:,:] = np.einsum('ij,ij -&gt; ij',offset,sin)\n        TM[1,0,:,:] = np.einsum('ij,ij -&gt; ij',sin,1/offset)\n        TM[1,1,:,:] = cos\n\n        return(TM)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_Maa_MPP_TM","title":"<code>_create_Maa_MPP_TM(Zp)</code>","text":"<p>Creates the transfer matrix for a Maa microperforated panel layer in either normal or diffuse sound fields</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_Maa_MPP_TM--parameters","title":"Parameters","text":"<p>Zp (ndarray):     Characteristic impedance of the layer</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._create_Maa_MPP_TM--returns","title":"Returns","text":"<p>TM (ndarray):     Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix     Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def _create_Maa_MPP_TM(self,\n                       Zp: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Creates the transfer matrix for a Maa microperforated panel layer in either normal or diffuse sound fields\n\n    Parameters\n    ----------\n    Zp (ndarray):\n        Characteristic impedance of the layer\n\n    Returns\n    -------\n    TM (ndarray):\n        Normal incidence --&gt; 2 x 2 x len(frequency) numpy array representing the transfer matrix\n        Diffuse field --&gt; 2 x 2 x len(frequency) x len(angles) array representing the transfer matrix\n\n    \"\"\"\n    if self.incidence == \"Normal\":\n        TM = np.zeros((2,2,len(self.frequency)),dtype = 'complex_')\n        TM[0][0] = 1\n        TM[0][1] = Zp\n        TM[1][0] = 0\n        TM[1][1] = 1\n\n        return (TM)\n\n    elif self.incidence == \"Diffuse\":\n        angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n\n        TM = np.zeros((2,2,len(self.frequency),len(angles)),dtype = 'complex_')\n\n        count = 0\n        for theta in angles:\n\n            TM[0,0,:,count] = 1\n            TM[0,1,:,count] = Zp*np.cos(np.radians(theta))\n            TM[1,0,:,count] = 0\n            TM[1,1,:,count] = 1\n            count += 1\n\n        return(TM)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._calc_dynamics","title":"<code>_calc_dynamics(flow_resistivity, porosity, tortuosity, viscous_characteristic_length, thermal_characteristic_length, thermal_permeability, thermal_tortuosity, viscous_tortuosity, model)</code>","text":"<p>Calculates the dynamic mass density and bulk modulus for porous, equivalent fluid models.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._calc_dynamics--parameters","title":"Parameters","text":"<p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>tortuosity (float):     high frequency limit of the tortuosity of the material</p> <p>viscous_characteristic_length (float):     viscous characteristic length of the material [m]</p> <p>thermal_characteristic_length (float):     thermal characteristic length of the material [m]</p> <p>thermal_permeability (float):     static thermal permeability of the material [m2]</p> <p>thermal_tortuosity (float):     static thermal tortuosity of the material</p> <p>viscous_tortuosity (float):     static viscous tortuosity of the material</p> <p>model (str):     defines the equivalent fluid model to be used</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._calc_dynamics--returns","title":"Returns","text":"<p>peff, keff (tuple(ndarray, ndarray)):     arrays of shape [len(frequency),1] representing the dynamic mass density     and bulk modulus of the material</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def _calc_dynamics(self,\n                   flow_resistivity: float,\n                   porosity: float,\n                   tortuosity: float,\n                   viscous_characteristic_length: float,\n                   thermal_characteristic_length: float,\n                   thermal_permeability: float,\n                   thermal_tortuosity: float,\n                   viscous_tortuosity: float,\n                   model: str) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates the dynamic mass density and bulk modulus for porous, equivalent fluid models.\n\n    Parameters\n    ----------\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    tortuosity (float):\n        high frequency limit of the tortuosity of the material\n\n    viscous_characteristic_length (float):\n        viscous characteristic length of the material [m]\n\n    thermal_characteristic_length (float):\n        thermal characteristic length of the material [m]\n\n    thermal_permeability (float):\n        static thermal permeability of the material [m2]\n\n    thermal_tortuosity (float):\n        static thermal tortuosity of the material\n\n    viscous_tortuosity (float):\n        static viscous tortuosity of the material\n\n    model (str):\n        defines the equivalent fluid model to be used\n\n\n    Returns\n    -------\n    peff, keff (tuple(ndarray, ndarray)):\n        arrays of shape [len(frequency),1] representing the dynamic mass density\n        and bulk modulus of the material\n\n    \"\"\"\n    fr = flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length\n    tcl = thermal_characteristic_length\n    kprime = thermal_permeability\n    tauprime = thermal_tortuosity\n    tau0 = viscous_tortuosity\n\n    w = self.ang_freq\n\n    if model == 'DB':\n        #Delaney-Bazley Model\n        DB_Param = (self.frequency*self.density_temp)/fr\n\n        a = DB_Param**-.754\n        b = DB_Param**-.732\n        c = DB_Param**-.700\n        d = DB_Param**-.595\n\n        Zr = self.Z0*(1+.0571*a)\n        Zi = self.Z0*.0870*b\n        kr = self.k0*(1+.0978*c)\n        ki = .189*self.k0*d\n\n\n        Zp = Zr-(1j*Zi)\n        kp = kr-(1j*ki)\n\n        peff = (Zp*kp)/w\n        keff = (Zp*w)/kp\n\n    elif model == 'DBM':\n        #Delaney-Bazley-Miki Model\n        DBM_Param = self.frequency/fr\n\n        a = DBM_Param**-.632\n        b = DBM_Param**-.618\n\n        Zr = self.Z0*(1+.0699*a)\n        Zi = self.Z0*.107*a\n        kr = self.k0*(1+.109*b)\n        ki = .160*self.k0*b\n\n        Zp = Zr-(1j*Zi)\n        kp = kr-(1j*ki)\n\n        peff = (Zp*kp)/w\n        keff = (Zp*w)/kp\n\n    elif model == 'JCA':\n        #Johnson-Champoux-Allard Model\n        wp = (w*self.density_temp*tau)/(fr*phi)\n        wpp = ((tcl**2)*self.Pr_temp*self.density_temp*w)/(8*self.viscosity_temp)\n        p=1\n        m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n        pprime = 1\n        mprime = 1\n\n        Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n        aw = tau*(1+(Fw/(1j*wp)))\n\n        Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n        bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n        peff = self.density_temp*aw/phi\n        keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n    elif model == 'JCAL':\n        #Johnson-Champoux-Allard-Lafarge Model\n        wp = (w*self.density_temp*tau)/(fr*phi)\n        wpp = (w*self.density_temp*self.Pr_temp*kprime)/(self.viscosity_temp*phi)\n        p = 1\n        m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n        pprime = 1\n        mprime = (8*kprime)/(phi*(tcl**2))\n\n        Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n        aw = tau*(1+(Fw/(1j*wp)))\n\n        Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n        bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n        peff = self.density_temp*aw/phi\n        keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n    elif model == 'JCAPL':\n        #Johnson-Champoux-Allard-Pride-Lafarge Model\n        wp = (w*self.density_temp*tau)/(fr*phi)\n        wpp = (w*self.density_temp*self.Pr_temp*kprime)/(self.viscosity_temp*phi)\n        m = (8*self.viscosity_temp*tau)/(fr*phi*(vcl**2))\n        p = m/(4*((tau0/tau)-1))\n        mprime = (8*kprime)/(phi*(tcl**2))\n        pprime = mprime/((4*(tauprime-1)))\n\n        Fw = 1-p+(p*np.sqrt(1+((1j*m*wp)/(2*(p**2)))))\n        aw = tau*(1+(Fw/(1j*wp)))\n\n        Fwp = 1-pprime+(pprime*np.sqrt(1+((1j*mprime*wpp)/(2*(pprime**2)))))\n        bw = self.gamma_temp-((self.gamma_temp-1)*((1+(Fwp/(1j*wpp)))**-1)) \n\n        peff = self.density_temp*aw/phi\n        keff = ((self.gamma_temp*self.P0)/(phi*bw))\n\n    return (peff,keff)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Air_Layer","title":"<code>Add_Air_Layer(thickness=400, save_layer=False, layer_name=None)</code>","text":"<p>Define an air gap layer</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Air_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     air gap thickness [mm]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Air_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Air_Layer(self,\n                  thickness: float=400,\n                  save_layer: bool = False,\n                  layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define an air gap layer\n\n    Parameters\n    ----------\n    thickness (float):\n        air gap thickness [mm]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'AIR','null',thickness,'null','null','null','null','null','null','null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    Zp = np.full(len(self.frequency),self.Z0)\n    thickness = thickness / 1000\n    TM = self._create_layer_TM(Zp,self.k0,thickness)\n\n    return([TM,0,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DB_Layer","title":"<code>Add_DB_Layer(thickness, flow_resistivity, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Delaney-Bazley Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DB_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resistivity (float):     static flow resistivity of the layer [Pa*s/m2]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DB_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list(ndarray, float, str):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_DB_Layer(self,\n                 thickness: float,\n                 flow_resistivity: float,\n                 save_layer: bool = False,\n                 layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Delaney-Bazley Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resistivity (float):\n        static flow resistivity of the layer [Pa*s/m2]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list(ndarray, float, str):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"      \n    if save_layer == True:\n        params = [layer_name,'DB','null',thickness,flow_resistivity,'null','null','null','null','null','null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    dyns = self._calc_dynamics(flow_resistivity, 0, 0, 0, 0, 0, 0, 0, model='DB')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DBM_Layer","title":"<code>Add_DBM_Layer(thickness, flow_resistivity, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Delaney-Bazley-Miki Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DBM_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resistivity (float):     static flow resistivity of the layer [Pa*s/m2]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_DBM_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_DBM_Layer(self,\n                  thickness: float,\n                  flow_resistivity: float,\n                  save_layer: bool = False,\n                  layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Delaney-Bazley-Miki Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resistivity (float):\n        static flow resistivity of the layer [Pa*s/m2]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'DBM','null',thickness,flow_resistivity,'null','null','null','null','null','null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    dyns = self._calc_dynamics(flow_resistivity, 0, 0, 0, 0, 0, 0, 0, model='DB')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCA_Layer","title":"<code>Add_JCA_Layer(thickness, flow_resistivity, porosity, tortuosity, viscous_characteristic_length, thermal_characteristic_length, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Johnson-Champoux-Allard Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCA_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>tortuosity (float):     high frequency limit of the tortuosity of the material</p> <p>viscous_characteristic_length (float):     viscous characteristic length of the material [\u00b5m]</p> <p>thermal_characteristic_length (float):     thermal characteristic length of the material [\u00b5m]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCA_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_JCA_Layer(self,\n                  thickness: float,\n                  flow_resistivity: float,\n                  porosity: float,\n                  tortuosity: float,\n                  viscous_characteristic_length: float,\n                  thermal_characteristic_length: float,\n                  save_layer: bool = False,\n                  layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Johnson-Champoux-Allard Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    tortuosity (float):\n        high frequency limit of the tortuosity of the material\n\n    viscous_characteristic_length (float):\n        viscous characteristic length of the material [\u00b5m]\n\n    thermal_characteristic_length (float):\n        thermal characteristic length of the material [\u00b5m]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'JCA','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,'null','null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length*(1e-6)\n    tcl = thermal_characteristic_length*(1e-6)\n\n    dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, 0, 0, 0, model='JCA')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAL_Layer","title":"<code>Add_JCAL_Layer(thickness, flow_resistivity, porosity, tortuosity, viscous_characteristic_length, thermal_characteristic_length, thermal_permeability, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Johnson-Champoux-Allard-Lafarge Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAL_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>tortuosity (float):     high frequency limit of the tortuosity of the material</p> <p>viscous_characteristic_length (float):     viscous characteristic length of the material [\u00b5m]</p> <p>thermal_characteristic_length (float):     thermal characteristic length of the material [\u00b5m]</p> <p>thermal_permeability (float):     static thermal permeability of the material [m2]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAL_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_JCAL_Layer(self,\n                   thickness: float,\n                   flow_resistivity: float,\n                   porosity: float,\n                   tortuosity: float,\n                   viscous_characteristic_length: float,\n                   thermal_characteristic_length: float,\n                   thermal_permeability: float,\n                   save_layer: bool = False,\n                   layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Johnson-Champoux-Allard-Lafarge Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    tortuosity (float):\n        high frequency limit of the tortuosity of the material\n\n    viscous_characteristic_length (float):\n        viscous characteristic length of the material [\u00b5m]\n\n    thermal_characteristic_length (float):\n        thermal characteristic length of the material [\u00b5m]\n\n    thermal_permeability (float):\n        static thermal permeability of the material [m2]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'JCAL','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,'null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length*(1e-6)\n    tcl = thermal_characteristic_length*(1e-6)\n    kprime = thermal_permeability*(1e-10)\n\n    dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, 0, 0, model='JCAL')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAPL_Layer","title":"<code>Add_JCAPL_Layer(thickness, flow_resistivity, porosity, tortuosity, viscous_characteristic_length, thermal_characteristic_length, thermal_permeability, thermal_tortuosity, viscous_tortuosity, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Johnson-Champoux-Allard-Pride-Lafarge Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAPL_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>tortuosity (float):     high frequency limit of the tortuosity of the material</p> <p>viscous_characteristic_length (float):     viscous characteristic length of the material [\u00b5m]</p> <p>thermal_characteristic_length (float):     thermal characteristic length of the material [\u00b5m]</p> <p>thermal_permeability (float):     static thermal permeability of the material [m2]</p> <p>thermal_tortuosity (float):     static thermal tortuosity of the material</p> <p>viscous_tortuosity (float):     static viscous tortuosity of the material</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_JCAPL_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_JCAPL_Layer(self,\n                    thickness: float,\n                    flow_resistivity: float,\n                    porosity: float,\n                    tortuosity: float,\n                    viscous_characteristic_length: float,\n                    thermal_characteristic_length: float,\n                    thermal_permeability: float,\n                    thermal_tortuosity: float,\n                    viscous_tortuosity: float,\n                    save_layer: bool = False,\n                    layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Johnson-Champoux-Allard-Pride-Lafarge Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    tortuosity (float):\n        high frequency limit of the tortuosity of the material\n\n    viscous_characteristic_length (float):\n        viscous characteristic length of the material [\u00b5m]\n\n    thermal_characteristic_length (float):\n        thermal characteristic length of the material [\u00b5m]\n\n    thermal_permeability (float):\n        static thermal permeability of the material [m2]\n\n    thermal_tortuosity (float):\n        static thermal tortuosity of the material\n\n    viscous_tortuosity (float):\n        static viscous tortuosity of the material\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'JCAPL','null',thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,'null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = self.viscosity_temp/flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length*(1e-6)\n    tcl = thermal_characteristic_length*(1e-6)\n    kprime = thermal_permeability*(1e-10)\n    tauprime = thermal_tortuosity\n    tau0 = viscous_tortuosity\n\n    dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model='JCAPL')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Horoshenkov_Layer","title":"<code>Add_Horoshenkov_Layer(thickness, porosity, median_pore_size, pore_size_distribution, save_layer=False, layer_name=None)</code>","text":"<p>Define a layer using the Horoshenkov et al Model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Horoshenkov_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>porosity (float):     open porosity of the material</p> <p>median_pore_size (float):     median pore size of the material [\u00b5m]</p> <p>pore_size_distribution (float):     standard deviation in the pore size distribution</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Horoshenkov_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Horoshenkov_Layer(self,\n                          thickness: float,\n                          porosity: float,\n                          median_pore_size: float,\n                          pore_size_distribution: float,\n                          save_layer: bool = False,\n                          layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a layer using the Horoshenkov et al Model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    porosity (float):\n        open porosity of the material\n\n    median_pore_size (float):\n        median pore size of the material [\u00b5m]\n\n    pore_size_distribution (float):\n        standard deviation in the pore size distribution\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'horoshenkov','null',thickness,'null',porosity,'null','null','null','null','null','null','null','null','null',median_pore_size,pore_size_distribution]\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n    mps = median_pore_size*(1e-6)\n    psd = pore_size_distribution\n    phi = porosity\n\n    X = (psd*np.log(2))**2\n    tau = np.exp(4*X)\n    Z = phi*(mps**2)/(8*tau)\n\n\n    fr = (self.viscosity_temp/Z)*np.exp(6*X)\n    vcl = mps*np.exp((-5/2)*X)\n    tcl = mps*np.exp((3/2)*X)\n    kprime = Z/np.exp(-6*X)\n\n    dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, 0, 0, model='JCAL')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Limp_Layer","title":"<code>Add_Biot_Limp_Layer(EF_model, thickness, flow_resistivity, mass_density, porosity, tortuosity=0, viscous_characteristic_length=0, thermal_characteristic_length=0, thermal_permeability=0, thermal_tortuosity=0, viscous_tortuosity=0, save_layer=False, layer_name=None)</code>","text":"<p>Define a limp Biot layer, using any of the equivalent fluid models</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Limp_Layer--parameters","title":"Parameters","text":"<p>EF_model (str):     Equivalent fluid model to be used:     DB --&gt; Delaney-Bazley     DBM --&gt; Delaney-Bazley-Miki     JCA --&gt; Johnson-Champoux-Allard     JCAL --&gt; Johnson-Champoux-Allar-Lafarge     JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge</p> <p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>mass_density (float):     bulk density of the material [kg/m3]</p> <p>tortuosity (float):, optional     high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.</p> <p>viscous_characteristic_length (float):, optional     viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.</p> <p>thermal_characteristic_length (float):, optional     thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.</p> <p>thermal_permeability (float):, optional     static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.</p> <p>thermal_tortuosity (float):, optional     static thermal tortuosity of the material. Needed for JCAPL models.</p> <p>viscous_tortuosity (float):, optional     static viscous tortuosity of the material. Needed for JCAPL models.</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Limp_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Biot_Limp_Layer(self,\n                        EF_model: str,\n                        thickness: float,\n                        flow_resistivity: float,\n                        mass_density: float,\n                        porosity: float,\n                        tortuosity: float=0,\n                        viscous_characteristic_length: float=0,\n                        thermal_characteristic_length: float=0,\n                        thermal_permeability: float=0,\n                        thermal_tortuosity: float=0,\n                        viscous_tortuosity: float=0,\n                        save_layer: bool = False,\n                        layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n    \"\"\"\n    Define a limp Biot layer, using any of the equivalent fluid models\n\n    Parameters\n    ----------\n    EF_model (str):\n        Equivalent fluid model to be used:\n        DB --&gt; Delaney-Bazley\n        DBM --&gt; Delaney-Bazley-Miki\n        JCA --&gt; Johnson-Champoux-Allard\n        JCAL --&gt; Johnson-Champoux-Allar-Lafarge\n        JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge\n\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    mass_density (float):\n        bulk density of the material [kg/m3]\n\n    tortuosity (float):, optional\n        high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.\n\n    viscous_characteristic_length (float):, optional\n        viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.\n\n    thermal_characteristic_length (float):, optional\n        thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.\n\n    thermal_permeability (float):, optional\n        static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.\n\n    thermal_tortuosity (float):, optional\n        static thermal tortuosity of the material. Needed for JCAPL models.\n\n    viscous_tortuosity (float):, optional\n        static viscous tortuosity of the material. Needed for JCAPL models.\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'biot_limp',EF_model,thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,mass_density,'null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length*(1e-6)\n    tcl = thermal_characteristic_length*(1e-6)\n    kprime = thermal_permeability*(1e-10)\n    tauprime = thermal_tortuosity\n    tau0 = viscous_tortuosity\n\n    if EF_model == 'JCA':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'JCAL':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'JCAPL':\n        fr = self.viscosity_temp/fr\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'DB':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'DBM':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    rho_tilde = mass_density+(phi*self.density_temp)-((self.density_temp**2)/peff)       ##eq. 15\n\n    gamma_tilde = (self.density_temp/peff)-1     #eq. 16\n\n    rho_eq_limp = (1/(phi*peff)) + ((gamma_tilde**2)/(phi*rho_tilde))    #eq. 24\n\n    rho_eq_limp = 1/rho_eq_limp\n\n    Zp = np.sqrt(rho_eq_limp*keff)\n    kp = self.ang_freq*np.sqrt(rho_eq_limp/keff)\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Rigid_Layer","title":"<code>Add_Biot_Rigid_Layer(EF_model, thickness, flow_resistivity, mass_density, porosity, tortuosity=0, viscous_characteristic_length=0, thermal_characteristic_length=0, thermal_permeability=0, thermal_tortuosity=0, viscous_tortuosity=0, save_layer=False, layer_name=None)</code>","text":"<p>Define a rigid Biot layer, using any of the equivalent fluid models</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Rigid_Layer--parameters","title":"Parameters","text":"<p>EF_model (str):     Equivalent fluid model to be used:     DB --&gt; Delaney-Bazley     DBM --&gt; Delaney-Bazley-Miki     JCA --&gt; Johnson-Champoux-Allard     JCAL --&gt; Johnson-Champoux-Allar-Lafarge     JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge</p> <p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>mass_density (float):     bulk density of the material [kg/m3]</p> <p>tortuosity (float):, optional     high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.</p> <p>viscous_characteristic_length (float):, optional     viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.</p> <p>thermal_characteristic_length (float):, optional     thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.</p> <p>thermal_permeability (float):, optional     static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.</p> <p>thermal_tortuosity (float):, optional     static thermal tortuosity of the material. Needed for JCAPL models.</p> <p>viscous_tortuosity (float):, optional     static viscous tortuosity of the material. Needed for JCAPL models.</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Biot_Rigid_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Biot_Rigid_Layer(self,\n                         EF_model: str,\n                         thickness: float,\n                         flow_resistivity: float,\n                         mass_density: float,\n                         porosity: float,\n                         tortuosity: float=0,\n                         viscous_characteristic_length: float=0,\n                         thermal_characteristic_length: float=0,\n                         thermal_permeability: float=0,\n                         thermal_tortuosity: float=0,\n                         viscous_tortuosity: float=0,\n                         save_layer: bool = False,\n                         layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n    \"\"\"\n    Define a rigid Biot layer, using any of the equivalent fluid models\n\n    Parameters\n    ----------\n    EF_model (str):\n        Equivalent fluid model to be used:\n        DB --&gt; Delaney-Bazley\n        DBM --&gt; Delaney-Bazley-Miki\n        JCA --&gt; Johnson-Champoux-Allard\n        JCAL --&gt; Johnson-Champoux-Allar-Lafarge\n        JCAPL --&gt; Johnson-Champoux-Allard-Pride-Lafarge\n\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    mass_density (float):\n        bulk density of the material [kg/m3]\n\n    tortuosity (float):, optional\n        high frequency limit of the tortuosity of the material. Needed for JCA, JCAL, and JCAPL models.\n\n    viscous_characteristic_length (float):, optional\n        viscous characteristic length of the material [\u00b5m]. Needed for JCA, JCAL, and JCAPL models.\n\n    thermal_characteristic_length (float):, optional\n        thermal characteristic length of the material [\u00b5m]. Needed for JCA, JCAL and JCAPL models.\n\n    thermal_permeability (float):, optional\n        static thermal permeability of the material [m2]. Needed for JCAL and JCAPL models.\n\n    thermal_tortuosity (float):, optional\n        static thermal tortuosity of the material. Needed for JCAPL models.\n\n    viscous_tortuosity (float):, optional\n        static viscous tortuosity of the material. Needed for JCAPL models.\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'biot_rigid',EF_model,thickness,flow_resistivity,porosity,tortuosity,viscous_characteristic_length,thermal_characteristic_length,thermal_permeability,thermal_tortuosity,viscous_tortuosity,mass_density,'null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = flow_resistivity\n    tau = tortuosity\n    phi = porosity\n    vcl = viscous_characteristic_length*(1e-6)\n    tcl = thermal_characteristic_length*(1e-6)\n    kprime = thermal_permeability*(1e-10)\n    tauprime = thermal_tortuosity\n    tau0 = viscous_tortuosity\n\n\n    if EF_model == 'JCA':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'JCAL':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'JCAPL':\n        fr = self.viscosity_temp/fr\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'DB':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n    elif EF_model == 'DBM':\n        peff,keff = self._calc_dynamics(fr, phi, tau, vcl, tcl, kprime, tauprime, tau0, model=EF_model)\n\n\n    rho_tilde = mass_density+(phi*self.density_temp)-((self.density_temp**2)/peff)   #eq. 15\n\n    gamma_tilde = (self.density_temp/peff)-1     #e. 16\n\n    rho_eq_limp = (1/(phi*peff)) + ((gamma_tilde**2)/(phi*rho_tilde)) + (((1-phi)/phi)*(gamma_tilde/rho_tilde))  #eq. 23\n\n    rho_eq_limp = 1/rho_eq_limp\n\n    Zp = np.sqrt(rho_eq_limp*keff)\n    kp = self.ang_freq*np.sqrt(rho_eq_limp/keff)\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Resistive_Screen","title":"<code>Add_Resistive_Screen(thickness, flow_resistivity, porosity, save_layer=False, layer_name=None)</code>","text":"<p>Define a resistive screen layer</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Resistive_Screen--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>flow_resisitivty (float):     Static air flow resistivity of the material [Pa*s/m2]</p> <p>porosity (float):     open porosity of the material</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Resistive_Screen--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Resistive_Screen(self,\n                         thickness: float,\n                         flow_resistivity: float,\n                         porosity: float,\n                         save_layer: bool = False,\n                         layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n\n\n    \"\"\"\n    Define a resistive screen layer\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    flow_resisitivty (float):\n        Static air flow resistivity of the material [Pa*s/m2]\n\n    porosity (float):\n        open porosity of the material\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'screen','null',thickness,flow_resistivity,porosity,'null','null','null','null','null','null','null','null','null','null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    fr = flow_resistivity\n    phi = porosity\n\n    w = self.ang_freq\n\n    keff = self.P0/phi\n    peff = ((self.density_temp/phi)+(fr/(1j*w)))\n\n    Zp = np.sqrt(peff*keff)\n    kp = self.ang_freq*np.sqrt(peff/keff)\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MAA_MPP_Layer","title":"<code>Add_MAA_MPP_Layer(thickness, pore_diameter, c_to_c_dist, save_layer=False, layer_name=None)</code>","text":"<p>Define a microperforated layer using Maa's model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MAA_MPP_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>pore_diameter (float):     diameter of the microperforate [mm]</p> <p>c_to_c_dist (float):     center to center distance of the microperforates [mm]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MAA_MPP_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_MAA_MPP_Layer(self,\n                      thickness: float,\n                      pore_diameter: float,\n                      c_to_c_dist: float,\n                      save_layer: bool = False,\n                      layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n\n    \"\"\"\n    Define a microperforated layer using Maa's model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    pore_diameter (float):\n        diameter of the microperforate [mm]\n\n    c_to_c_dist (float):\n        center to center distance of the microperforates [mm]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'MAA_MPP','null',thickness,'null','null','null','null','null','null','null','null','null',pore_diameter,c_to_c_dist,'null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    d = pore_diameter/1000\n    b = c_to_c_dist/1000\n\n    w = self.ang_freq\n\n    x = d*np.sqrt((w*self.density_temp)/(4*self.viscosity_temp))\n    phi = (np.pi/4)*((d/b)**2)\n\n    x = d/2*np.sqrt(w*self.density_temp/(self.viscosity_temp))\n    r1 = np.sqrt(1+x**2/32)+np.sqrt(2)/32*x*d/thickness\n    r = 32*self.viscosity_temp/phi*thickness/d**2*r1\n    m1 = 1+1/np.sqrt(1+x**2/2)+0.85*d/thickness\n    m = self.density_temp*thickness/phi*m1\n\n    Zp = (r+(1j*w*m))\n\n    TM = self._create_Maa_MPP_TM(Zp)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MPP_EF_Layer","title":"<code>Add_MPP_EF_Layer(thickness, pore_diameter, c_to_c_dist, save_layer=False, layer_name=None)</code>","text":"<p>Define a microperforated layer using an equivalent fluid model</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MPP_EF_Layer--parameters","title":"Parameters","text":"<p>thickness (float):     layer thickness [mm]</p> <p>pore_diameter (float):     diameter of the microperforate [mm]</p> <p>c_to_c_dist (float):     center to center distance of the microperforates [mm]</p> <p>save_layer (bool):     Specify whether to save the input parameters to a database for later use.</p> <p>layer_name (str):     If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_MPP_EF_Layer--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_MPP_EF_Layer(self,\n                     thickness: float,\n                     pore_diameter: float,\n                     c_to_c_dist: float,\n                     save_layer: bool = False,\n                     layer_name: str = None) -&gt; list[np.ndarray, float, str]:\n    \"\"\"\n    Define a microperforated layer using an equivalent fluid model\n\n    Parameters\n    ----------\n    thickness (float):\n        layer thickness [mm]\n\n    pore_diameter (float):\n        diameter of the microperforate [mm]\n\n    c_to_c_dist (float):\n        center to center distance of the microperforates [mm]\n\n    save_layer (bool):\n        Specify whether to save the input parameters to a database for later use.\n\n    layer_name (str):\n        If save_layer is set to True, specify the name of the layer.  Must be a unique identifier.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    if save_layer == True:\n        params = [layer_name,'EF_MPP','null',thickness,'null','null','null','null','null','null','null','null','null',pore_diameter,c_to_c_dist,'null','null']\n        self._layer_to_db(params)\n\n    thickness = thickness/1000\n\n    d = pore_diameter/1000\n    b = c_to_c_dist/1000\n\n    phi = (np.pi/4)*((d/b)**2)\n\n    eps = 2.0*np.sqrt(phi/np.pi)\n    fok = (1-(1.13*eps)-(0.09*(eps**2))+(0.27*(eps**3)))*(4*d/3*np.pi)\n    fr = (32*self.viscosity_temp)/(phi*(d**2))\n\n    vcl = d/2\n    tcl = d/2\n\n    tau = 1+(2*fok/thickness)\n\n    dyns = self._calc_dynamics(fr, phi, tau, vcl, tcl, 0, 0, 0, model='JCA')\n\n    Zp = np.sqrt(dyns[0]*dyns[1])\n    kp = self.ang_freq*np.sqrt(dyns[0]/dyns[1])\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    return([TM,thickness,layer_name])\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Tube","title":"<code>Add_Layer_From_Tube(no_gap_file, gap_file, sample_thickness, air_gap_thickness, measurement='reflection')</code>","text":"<p>Define a layer from the normal incidence reflection coefficients or the surface impedance of a material obtained from an impedance tube.  Utsuno's method currently implemented.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Tube--parameters","title":"Parameters","text":"<p>no_gap_file (str):     Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained      from an impedence tube measurement with rigid backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and      coefficients in the 2nd.</p> <p>gap_file (str):     Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained      from an impedence tube measurement with an air gap backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and      coefficients in the 2nd.</p> <p>sample_thickness (float):     thickness of the sample [mm]</p> <p>air_gap_thickness (float):     thickness of the air gap [mm] in the gap mounting condition.</p> <p>measurement (str):     'reflection' or 'surface' measurement types used in the No_Gap and Gap parameters.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Tube--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Layer_From_Tube(self,\n                        no_gap_file: str,\n                        gap_file: str,\n                        sample_thickness: float,\n                        air_gap_thickness: float,\n                        measurement: str = 'reflection') -&gt; list[np.ndarray, float, str]:\n\n\n\n    \"\"\"\n    Define a layer from the normal incidence reflection coefficients or the surface impedance of a material obtained from\n    an impedance tube.  Utsuno's method currently implemented.\n\n    Parameters\n    ----------\n    no_gap_file (str):\n        Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained \n        from an impedence tube measurement with rigid backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and \n        coefficients in the 2nd.\n\n    gap_file (str):\n        Name of the csv filepath that contains the frequency dependent absorption, reflection, or surface impedance coefficients of a single porous layer obtained \n        from an impedence tube measurement with an air gap backing.  The csv file should contain 2 columns of equal length -- the frequencies in the 1st column and \n        coefficients in the 2nd.\n\n    sample_thickness (float):\n        thickness of the sample [mm]\n\n    air_gap_thickness (float):\n        thickness of the air gap [mm] in the gap mounting condition.\n\n    measurement (str):\n        'reflection' or 'surface' measurement types used in the No_Gap and Gap parameters.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n\n    \"\"\"\n    thickness = sample_thickness/1000\n    air_thickness = air_gap_thickness/1000\n\n\n    no_gap_data = self.load_to_array(no_gap_file)\n    gap_data = self.load_to_array(gap_file)\n\n    if measurement == 'surface':\n        Zs_NG = no_gap_data[:,1]\n        Zs_G = gap_data[:,1]\n\n    elif measurement == 'reflection':\n        Zs_NG = self.Z0*((1+no_gap_data[:,1])/(1-no_gap_data[:,1]))\n        Zs_G = self.Z0*((1+gap_data[:,1])/(1-gap_data[:,1]))\n\n    if np.array_equal(no_gap_data[:,0],gap_data[:,0]) != True:\n        raise ValueError(\"Frequencies must match between no gap and gap curves\")\n\n    T11A = np.cos(self.k0*air_thickness)\n    T21A = (1j/self.Z0)*np.sin(self.k0*air_thickness)\n    Zs_A = T11A/T21A\n\n    Zp = np.sqrt((Zs_G*(Zs_NG+Zs_A))-(Zs_NG*Zs_A))\n    kp = np.arctan(Zp/(1j*Zs_NG))/thickness\n\n    TM = self._create_layer_TM(Zp,kp,thickness)\n\n    for n in range(1,10):\n        rhs = int((n*self.soundspeed_temp)/(2*air_thickness))\n        if rhs &lt; self.fmax:\n            print(f\"Caution: results near {rhs} Hz may be unreliable due to air gap selection!\")\n\n    return([TM,thickness,None]) \n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Database","title":"<code>Add_Layer_From_Database(layer_name)</code>","text":"<p>Define a layer from properties that have been saved to a database.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Database--parameters","title":"Parameters","text":"<p>layer_name (str):     The unique name the layer was saved to the database as.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.Add_Layer_From_Database--returns","title":"Returns","text":"<p>TM, thickness, layer_name (list[ndarray, float, str]):     The transfer matrix, thickness, and name of the layer.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def Add_Layer_From_Database(self,\n                            layer_name: str) -&gt; list[np.ndarray, float, str]:\n\n    '''\n    Define a layer from properties that have been saved to a database.\n\n    Parameters\n    ----------\n    layer_name (str):\n        The unique name the layer was saved to the database as.\n\n    Returns\n    -------\n    TM, thickness, layer_name (list[ndarray, float, str]):\n        The transfer matrix, thickness, and name of the layer.\n    '''\n\n    s = AcoustiBase()\n\n    data = s.query(\"SELECT * from LAYER WHERE name = ?\", (layer_name,))\n    model_type = data[0][2]\n\n    if model_type == 'DB':\n        layer = self.Add_DB_Layer(data[0][4], data[0][5])\n        return(layer)\n\n    elif model_type == 'DBM':\n        layer = self.Add_DBM_Layer(data[0][4], data[0][5])\n        return(layer)\n\n    elif model_type == 'JCA':\n        layer = self.Add_JCA_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9])\n        return(layer)\n\n    elif model_type == 'JCAL':\n        layer = self.Add_JCAL_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10])\n        return(layer)\n\n    elif model_type == 'JCAPL':\n        layer = self.Add_JCAPL_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11],data[0][12])\n        return(layer)\n\n    elif model_type == 'horoshenkov':\n        layer = self.Add_Horoshenkov_Layer(data[0][4],data[0][6],data[0][16],data[0][17])\n        return(layer)\n\n    elif model_type == 'biot_rigid':\n        layer = self.Add_Biot_Rigid_Layer(data[0][3],data[0][4], data[0][5], data[0][13], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11], data[0][12])\n        return(layer)\n\n    elif model_type == 'biot_limp':\n        layer = self.Add_Biot_Limp_Layer(data[0][3],data[0][4], data[0][5], data[0][13], data[0][6], data[0][7], data[0][8], data[0][9], data[0][10], data[0][11], data[0][12])\n        return(layer)\n\n    elif model_type == 'screen':\n        layer = self.Add_Resistive_Screen(data[0][4], data[0][5], data[0][6])\n        return(layer)\n\n    elif model_type == 'MAA_MPP':\n        layer = self.Add_MAA_MPP_Layer(data[0][4], data[0][14], data[0][15])\n        return(layer)\n\n    elif model_type == 'EF_MPP':\n        layer = self.Add_MPP_EF_Layer(data[0][4], data[0][14], data[0][15])\n        return(layer)\n\n    elif model_type == 'identified':\n        layer = self.Add_JCA_Layer(data[0][4], data[0][5], data[0][6], data[0][7], data[0][8], data[0][9])\n        return(layer)\n\n    elif model_type == 'AIR':\n        layer = self.Add_Air_Layer(data[0][4])\n        return(layer)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_from_database","title":"<code>assemble_from_database(name)</code>","text":"<p>Define a multilayer structure that has been saved to a database.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_from_database--parameters","title":"Parameters","text":"<p>name (str):     The unique name the multilayer structure was saved to the database as.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_from_database--returns","title":"Returns","text":"<p>Tt,thickness (list[ndarray, float]):     The total transfer matrix and total thickness of the structure.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def assemble_from_database(self,\n                           name: str) -&gt; list[np.ndarray, float]:\n    '''\n    Define a multilayer structure that has been saved to a database.\n\n    Parameters\n    ----------\n    name (str):\n        The unique name the multilayer structure was saved to the database as.\n\n    Returns\n    -------\n    Tt,thickness (list[ndarray, float]):\n        The total transfer matrix and total thickness of the structure.\n    '''\n    s = AcoustiBase()\n\n    data = s.query(\"SELECT * from STRUCTURE WHERE structure_name = ?\", (name,))[0]\n    data = data[2:]\n\n    layers = []\n\n    for d in data:\n        if d != 'null':\n            layers.append(self.Add_Layer_From_Database(d))\n\n    structure = self.assemble_structure(layers,db_flag=True)\n\n    return(structure)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_structure","title":"<code>assemble_structure(*kwargs, save_structure=False, structure_name=None, db_flag=False)</code>","text":"<p>Calculates the total transfer matrix for a structure of 'n' number of layers.  The structure is defined from left to right --&gt; left being the face of the structure where sound impinges on the surface and right being the back or bottom of the structure that sound propagates through.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_structure--parameters","title":"Parameters","text":"<p>*kwargs (list):     individual transfer matrices, thicknesses, and names of each layer, which is returned by any of the \"Add_XXX_Layer\" methods.</p> <p>save_structure (bool):     Specify whether to save the structure to a database for later use.</p> <p>structure_name (str):     If save_structure is set to True, specify the name of the structure.  Must be a unique identifier.</p> <p>db_flag (bool):     DO NOT CHANGE THIS PARAMETER -- for internal calclations only.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.assemble_structure--returns","title":"Returns","text":"<p>Tt,thickness list([ndarray, float]):     The total transfer matrix and total thickness of the structure.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def assemble_structure(self,\n                       *kwargs,\n                       save_structure: bool=False,\n                       structure_name: str=None,\n                       db_flag: bool=False) -&gt; list[np.ndarray, float]:\n    \"\"\"\n    Calculates the total transfer matrix for a structure of 'n' number of layers.  The structure is defined from left to right --&gt; left being the face\n    of the structure where sound impinges on the surface and right being the back or bottom of the structure that sound propagates through.\n\n    Parameters\n    ----------\n    *kwargs (list):\n        individual transfer matrices, thicknesses, and names of each layer, which is returned by any of the \"Add_XXX_Layer\" methods.\n\n    save_structure (bool):\n        Specify whether to save the structure to a database for later use.\n\n    structure_name (str):\n        If save_structure is set to True, specify the name of the structure.  Must be a unique identifier.\n\n    db_flag (bool):\n        DO NOT CHANGE THIS PARAMETER -- for internal calclations only.\n\n    Returns\n    -------\n    Tt,thickness list([ndarray, float]):\n        The total transfer matrix and total thickness of the structure.\n\n    \"\"\"\n\n    transfer_matrices = []\n    layer_thickness = []\n    layer_names = []\n\n    if db_flag == True:\n        for i in range(len(kwargs[0])):\n            transfer_matrices.append(kwargs[0][i][0])\n            layer_thickness.append(kwargs[0][i][1])\n            layer_names.append(kwargs[0][i][2])\n\n\n    else:\n        for kwarg in kwargs:\n            transfer_matrices.append(kwarg[0])\n            layer_thickness.append(kwarg[1])\n            layer_names.append(kwarg[2])\n\n\n    if save_structure == True:\n        s = AcoustiBase()\n        data = s.pull('STRUCTURE')\n        id1 = len(data)+1\n        param_base = [id1,structure_name]\n        for layer in layer_names:\n            param_base.append(layer)\n\n        params = param_base.copy()\n        for i in range(18-len(param_base)):\n            params.append('null')\n        s.execute(params,'STRUCTURE')\n        s.commit()\n        s.close()\n\n    thickness = sum(layer_thickness)\n    if self.incidence == 'Normal':\n\n        if len(transfer_matrices) == 1:\n            Tt = transfer_matrices[0]\n            return([Tt,thickness])\n\n        elif len(transfer_matrices) &gt; 1:\n            Tt = np.einsum('ijn,jkn-&gt;ikn', transfer_matrices[0], transfer_matrices[1])\n            for i in range(len(transfer_matrices)-2):\n                Tt = np.einsum('ijn,jkn-&gt;ikn', Tt, transfer_matrices[i+2])\n\n            return([Tt,thickness])\n\n        elif len(transfer_matrices) == 0:\n            raise ValueError(\"Error: Structure Not Defined. Specify each layer in assemble_structure.\")\n\n    elif self.incidence == \"Diffuse\":\n\n        if len(transfer_matrices) == 1:\n            Tt = transfer_matrices[0]\n            return([Tt,thickness])\n\n        elif len(transfer_matrices) &gt; 1:\n            Tt = np.einsum('ijnm,jknm-&gt;iknm', transfer_matrices[0], transfer_matrices[1])\n            for i in range(len(transfer_matrices)-2):\n                Tt = np.einsum('ijnm,jknm-&gt;iknm', Tt, transfer_matrices[i+2])\n\n            return([Tt,thickness])\n\n        elif len(transfer_matrices) == 0:\n            raise ValueError(\"Error: Structure Not Defined. Specify each layer in assemble_structure.\")\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.reflection","title":"<code>reflection(transfer_matrix)</code>","text":"<p>Calculates the frequency dependent reflection coefficients of the structure.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.reflection--parameters","title":"Parameters","text":"<p>transfer_matrix (list):     total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.reflection--returns","title":"Returns","text":"<p>curve (ndarray):     The 2D array of frequencies and reflection coefficients</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def reflection(self,\n               transfer_matrix: list) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the frequency dependent reflection coefficients of the structure.\n\n    Parameters\n    ----------\n    transfer_matrix (list):\n        total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n    Returns\n    -------\n    curve (ndarray):\n        The 2D array of frequencies and reflection coefficients\n\n    \"\"\"\n    Tt = transfer_matrix[0]\n\n    if self.incidence == 'Normal':\n        Zst = Tt[0][0] / Tt[1][0]\n\n        R = (Zst-self.Z0)/(Zst+self.Z0)\n\n        curve = np.column_stack((self.frequency,R))\n        return (curve)\n\n    elif self.incidence == \"Diffuse\":\n\n        angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n        v = np.cos(np.radians(angles))\n\n        Zst = Tt[0][0][:][:]/ Tt[1][0][:][:]\n        r = ((Zst*v)-self.Z0)/((Zst*v)+self.Z0)\n\n        thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n        num = np.sum(r*thetas,1)\n        denom = sum(thetas)\n\n        R = num/denom\n\n        curve = np.column_stack((self.frequency,R))\n        return (curve)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.absorption","title":"<code>absorption(transfer_matrix)</code>","text":"<p>Calculates the frequency dependent absorption coefficients of the structure.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.absorption--parameters","title":"Parameters","text":"<p>transfer_matrix (list):     total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.absorption--returns","title":"Returns","text":"<p>curve (ndarray):     The 2D array of frequencies and absorption coefficients</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def absorption(self,\n               transfer_matrix: list) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the frequency dependent absorption coefficients of the structure.\n\n    Parameters\n    ----------\n    transfer_matrix (list):\n        total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n    Returns\n    -------\n    curve (ndarray):\n        The 2D array of frequencies and absorption coefficients\n\n    \"\"\"\n    Tt = transfer_matrix[0]\n\n    if self.incidence == 'Normal':\n        Zst = Tt[0][0] / Tt[1][0]\n\n        R = (Zst-self.Z0)/(Zst+self.Z0)\n\n        A = 1-abs(R)**2\n        curve = np.column_stack((self.frequency,A))\n\n        return (curve)\n\n    elif self.incidence == \"Diffuse\":\n\n        angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n        v = np.cos(np.radians(angles))\n\n        Zst = Tt[0][0][:][:]/ Tt[1][0][:][:]\n        R = ((Zst*v)-self.Z0)/((Zst*v)+self.Z0)\n\n        a = 1-abs(R)**2\n\n        thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n        num = np.sum(a*thetas,1)\n        denom = sum(thetas)\n\n        A = num/denom\n        curve = np.column_stack((self.frequency,A))\n\n        return (curve)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.transmission_loss","title":"<code>transmission_loss(transfer_matrix)</code>","text":"<p>Calculates the frequency dependent transmission coefficients of the structure.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.transmission_loss--parameters","title":"Parameters","text":"<p>transfer_matrix (list):     total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.transmission_loss--returns","title":"Returns","text":"<p>curve (ndarray):     The 2D array of frequencies and transmission coefficients</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def transmission_loss(self,\n                      transfer_matrix: list) -&gt; np.ndarray:\n    \"\"\"\n    Calculates the frequency dependent transmission coefficients of the structure.\n\n    Parameters\n    ----------\n    transfer_matrix (list):\n        total transfer matrix and thickness of the structure, which is returned by the \"assemble_structure\" method.\n\n    Returns\n    -------\n    curve (ndarray):\n        The 2D array of frequencies and transmission coefficients\n\n    \"\"\"\n    Tt = transfer_matrix[0]\n    thickness = transfer_matrix[1]\n\n    if self.incidence == 'Normal':\n\n        T = (2.0*np.exp(1j*self.k0*thickness))/(Tt[0][0]+(Tt[0][1]/self.Z0)+(self.Z0*Tt[1][0])+Tt[1][1])\n        Te = abs(T)**2\n        TL = 10*np.log10(1/Te)\n\n\n        curve = np.column_stack((self.frequency,TL))\n        return (curve)\n\n    elif self.incidence == \"Diffuse\":\n\n        angles = np.arange(self.angles[0],self.angles[1],self.angles[2])\n        v = np.cos(np.radians(angles))\n\n        t1 = 2.0*np.exp(1j*self.k0*thickness)\n        t1 = np.tile(t1,(int((self.angles[1]-self.angles[0])/self.angles[2]),1)).T\n        t2 = (Tt[0][0][:][:]+(Tt[0][1][:][:]*v/self.Z0)+(self.Z0*Tt[1][0][:][:]/v)+Tt[1][1][:][:])\n        T = t1/t2 \n        Te = abs(T)**2\n\n\n        thetas = np.cos(np.radians(angles))*np.sin(np.radians(angles))\n\n        num = np.sum(Te*thetas,1)\n        denom = sum(thetas)\n\n        Tz = num/denom\n        TL = 10*np.log10(1/Tz)\n\n        curve = np.column_stack((self.frequency,TL))\n\n        return (curve)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.octave_bands","title":"<code>octave_bands(curve, kind='THIRD_OCTAVE')</code>","text":"<p>Calculates the third octave or octave band absorption or transmission spectrums</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.octave_bands--parameters","title":"Parameters","text":"<p>curve (ndarray):     The 2D array of frequencies and absorption or transmission coefficients, which is returend by the 'absorption' or 'transmission_loss' methods.</p> <p>kind (str):     'OCTAVE' or 'THIRD_OCTAVE'</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.octave_bands--returns","title":"Returns","text":"<p>octaves (ndarray):     The 2D array of octave bands and absorption or transmission coefficients</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def octave_bands(self,\n                 curve: np.ndarray,\n                 kind: str='THIRD_OCTAVE') -&gt; np.ndarray:\n    \"\"\"\n    Calculates the third octave or octave band absorption or transmission spectrums\n\n    Parameters\n    ----------\n    curve (ndarray):\n        The 2D array of frequencies and absorption or transmission coefficients, which is returend by the 'absorption' or 'transmission_loss' methods.\n\n    kind (str):\n        'OCTAVE' or 'THIRD_OCTAVE'\n\n    Returns\n    -------\n    octaves (ndarray):\n        The 2D array of octave bands and absorption or transmission coefficients\n\n    \"\"\"\n    if kind == 'OCTAVE':\n\n        fl = self.frequency[0]\n        fu = self.frequency[-1]\n\n        mid2 = 1000\n        spec_mid = []  \n        for i in range(int(len(self.OCTAVE_PREFERRED)/2)+1):\n            mid2 = mid2/(2**(1))\n\n        spec_mid = [mid2] \n        for i in range(int(len(self.OCTAVE_PREFERRED))-1):\n            mid2 = mid2*(2**(1))\n            spec_mid.append(mid2)\n\n        spec_mid = np.asarray(spec_mid)\n\n        bands = np.column_stack((self.OCTAVE_PREFERRED,spec_mid))\n\n        lower = []\n        upper = []\n        for n in bands[:,1]:\n            lower.append(n/((2**(1/2))**(1/1)))\n            upper.append(n*((2**(1/2))**(1/1)))\n\n        lower = np.asarray(lower)\n        upper = np.asarray(upper)\n\n        bands = np.column_stack((bands,lower))\n        bands = np.column_stack((bands,upper))\n\n        bands = bands[np.where((bands[:,2] &gt; fl) &amp; (bands[:,2] &lt; fu))]\n\n        octave_abs = []\n        for i in range(len(bands)):    \n            curve_range = curve[np.where((curve[:,0]&gt;=bands[i,2]) &amp; (curve[:,0]&lt;=bands[i,3]))]\n            ave = np.mean(curve_range[:,1])\n            octave_abs.append(ave)\n\n        octaves = np.column_stack((bands[:,0],octave_abs))\n        octaves = octaves[~np.isnan(octaves).any(axis=1)]\n\n        return(octaves)\n\n    elif kind == 'THIRD_OCTAVE':\n\n        fl = self.frequency[0]\n        fu = self.frequency[-1]\n\n        mid2 = 1000\n        spec_mid = []  \n        for i in range(int(len(self.THIRD_OCTAVE_PREFERRED)/2)+2):\n            mid2 = mid2/(2**(1/3))\n\n        spec_mid = [mid2] \n        for i in range(int(len(self.THIRD_OCTAVE_PREFERRED))-1):\n            mid2 = mid2*(2**(1/3))\n            spec_mid.append(mid2)\n\n        spec_mid = np.asarray(spec_mid)\n\n        bands = np.column_stack((self.THIRD_OCTAVE_PREFERRED,spec_mid))\n\n        lower = []\n        upper = []\n        for n in bands[:,1]:\n            lower.append(n/((2**(1/2))**(1/3)))\n            upper.append(n*((2**(1/2))**(1/3)))\n\n        lower = np.asarray(lower)\n        upper = np.asarray(upper)\n\n        bands = np.column_stack((bands,lower))\n        bands = np.column_stack((bands,upper))\n\n        bands = bands[np.where((bands[:,2] &gt; fl) &amp; (bands[:,2] &lt; fu))]\n\n        octave_abs = []\n        for i in range(len(bands)):    \n            curve_range = curve[np.where((curve[:,0]&gt;=bands[i,2]) &amp; (curve[:,0]&lt;=bands[i,3]))]\n            ave = np.mean(curve_range[:,1])\n            octave_abs.append(ave)\n\n        octaves = np.column_stack((bands[:,0],octave_abs))\n        octaves = octaves[~np.isnan(octaves).any(axis=1)]\n\n        return(octaves)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.SAA","title":"<code>SAA(third_octave_curve)</code>","text":"<p>Calculates the average sound absorption coefficient between the 200Hz and 2500Hz third octave frequency bands.  </p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.SAA--parameters","title":"Parameters","text":"<p>third_octave_curve (ndarray):     The 2D array of frequencies and absorption, which is returend by the 'octave_bands' method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.SAA--returns","title":"Returns","text":"<p>saa (float):     The average sound absorption coefficient, rounded to 3 decimal places</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def SAA(self,\n        third_octave_curve: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculates the average sound absorption coefficient between the 200Hz and 2500Hz third octave frequency bands.  \n\n    Parameters\n    ----------\n    third_octave_curve (ndarray):\n        The 2D array of frequencies and absorption, which is returend by the 'octave_bands' method.\n\n    Returns\n    -------\n    saa (float):\n        The average sound absorption coefficient, rounded to 3 decimal places\n\n    \"\"\"\n    try:\n        l = int(np.where((third_octave_curve[:,0] == 200))[0].item())\n        u = int(np.where((third_octave_curve[:,0] == 2500))[0].item()+1)\n\n        saa = third_octave_curve[l:u,:]\n        saa = round(np.mean(saa[:,1]),3)\n    except TypeError:\n        raise ValueError('Unable to Calculate SAA with given frequency range!')\n        return\n\n    return(saa)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.FFA","title":"<code>FFA(third_octave_curve)</code>","text":"<p>Calculates the four frequency average sound absorption coefficient at the 250Hz, 500Hz, 1000Hz, and 2000Hz third octave frequency bands.  </p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.FFA--parameters","title":"Parameters","text":"<p>third_octave_curve (ndarray):     The 2D array of frequencies and absorption, which is returned by the 'octave_bands' method.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.FFA--returns","title":"Returns","text":"<p>ffa (float):     The four frequency average sound absorption coefficient, rounded to 3 decimal places</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def FFA(self,\n        third_octave_curve: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculates the four frequency average sound absorption coefficient at the 250Hz, 500Hz, 1000Hz, and 2000Hz third octave frequency bands.  \n\n    Parameters\n    ----------\n    third_octave_curve (ndarray):\n        The 2D array of frequencies and absorption, which is returned by the 'octave_bands' method.\n\n    Returns\n    -------\n    ffa (float):\n        The four frequency average sound absorption coefficient, rounded to 3 decimal places\n\n    \"\"\"\n    absfreq = []\n    for i in (250,500,1000,2000):\n        try:\n            position = int(np.where((third_octave_curve[:,0] == i))[0].item())\n            absorption = third_octave_curve[position,1]\n            absfreq.append(absorption)\n        except TypeError:\n            raise ValueError('Unable to Calculate FFA with given frequency range!')\n            return\n\n    ffa = round(sum(absfreq)/4,3)\n\n    return(ffa)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.plot_curve","title":"<code>plot_curve(curves, labels=None, kind='LINEAR')</code>","text":"<p>Plots the frequency dependent reflection, absorption, or transmission coefficients of 1 or more structures.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.plot_curve--parameters","title":"Parameters","text":"<p>curves (list):     List of 2D arrays of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',     'absorption', or 'transmission_loss' methods.</p> <p>labels (list):, optional     List of strings to create a legend on the plot with labels</p> <p>kind (str):     'LINEAR' or 'LOG' --&gt; define whether the frequencies should be converted to a log scale for plotting purposes.</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def plot_curve(self,\n               curves: list,\n               labels: list = None,\n               kind: str ='LINEAR') -&gt; None:\n    \"\"\"\n    Plots the frequency dependent reflection, absorption, or transmission coefficients of 1 or more structures.\n\n    Parameters\n    ----------\n    curves (list):\n        List of 2D arrays of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',\n        'absorption', or 'transmission_loss' methods.\n\n    labels (list):, optional\n        List of strings to create a legend on the plot with labels\n\n    kind (str):\n        'LINEAR' or 'LOG' --&gt; define whether the frequencies should be converted to a log scale for plotting purposes.\n\n    \"\"\"\n    f, ax = plt.subplots(1)\n\n    if kind == 'LINEAR':\n        i=0\n        for curve in curves:\n            if labels is not None:\n                ax.plot(curve[:,0],curve[:,1],label=labels[i])\n                ax.legend(loc=\"lower right\")\n                i+=1\n            else:\n               ax.plot(curve[:,0],curve[:,1]) \n\n        ax.set_ylim(bottom=0)\n        plt.show()\n\n\n    elif kind == 'LOG':\n        i=0\n        for curve in curves:\n            if labels is not None:\n                logfreq = np.log10(curve[:,0])\n                ax.plot(logfreq,curve[:,1],label=labels[i])\n                ax.legend(loc=\"lower right\")\n                i+=1\n            else:\n                logfreq = np.log10(curve[:,0])\n                ax.plot(logfreq,curve[:,1])\n\n\n        ax.set_ylim(bottom=0)\n        plt.show()\n\n    return\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.to_csv","title":"<code>to_csv(filename, data)</code>","text":"<p>Saves the frequency dependent reflection, absorption, or transmission coefficients of a structure to a csv file without headers.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.to_csv--parameters","title":"Parameters","text":"<p>filename (str):     Name of the csv file to save data to</p> <p>data (ndarray):     2D array of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',     'absorption', or 'transmission_loss' methods</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def to_csv(self,\n           filename: str,\n           data: np.ndarray) -&gt; None:\n    \"\"\"\n    Saves the frequency dependent reflection, absorption, or transmission coefficients of a structure to a csv file without headers.\n\n    Parameters\n    ----------\n\n    filename (str):\n        Name of the csv file to save data to\n\n    data (ndarray):\n        2D array of frequencies and reflection, absorption, or transmission coefficients, which is retured by the 'reflection',\n        'absorption', or 'transmission_loss' methods\n\n    \"\"\"\n    if \".csv\" in filename:\n        file = filename\n    else:\n        file = filename+\".csv\"\n\n    save_path = os.path.join(file)\n    np.savetxt(save_path, data, delimiter=\",\")\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.load_to_array","title":"<code>load_to_array(filename, type='complex')</code>","text":"<p>Loads data from csv or excel file.</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM.load_to_array--parameters","title":"Parameters","text":"<p>filename (str):     Name of the file to load data from</p> <p>type (str):     type of data being loaded -- either complex or floating point data</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def load_to_array(self,\n                  filename: str,\n                  type: str ='complex') -&gt; None:\n    \"\"\"\n    Loads data from csv or excel file.\n\n    Parameters\n    ----------\n    filename (str):\n        Name of the file to load data from\n\n    type (str):\n        type of data being loaded -- either complex or floating point data\n\n    \"\"\"\n    if type == 'complex':\n        try:\n            data = np.asarray(pd.read_csv(filename,header=None).applymap(lambda s: np.complex128(s.replace('i', 'j'))))\n        except Exception:\n            data = np.asarray(pd.read_excel(filename,header=None).applymap(lambda s: np.complex128(s.replace('i', 'j'))))\n\n    elif type == 'float':\n        try:\n            data = np.asarray(pd.read_csv(filename,header=None))\n        except Exception:\n            data = np.asarray(pd.read_excel(filename,header=None))  \n\n    return (data)\n</code></pre>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._layer_to_db","title":"<code>_layer_to_db(params)</code>","text":"<p>Add a layer to the database</p>"},{"location":"AcousticTMM/#src.acoustipy.TMM.AcousticTMM._layer_to_db--parameters","title":"Parameters","text":"<p>params (list):     Attributes of the given layer</p> Source code in <code>src/acoustipy/TMM.py</code> <pre><code>def _layer_to_db(self,\n                params: list) -&gt; None:\n        '''\n        Add a layer to the database\n\n        Parameters\n        ----------\n        params (list):\n            Attributes of the given layer\n\n        '''\n        s = AcoustiBase()\n        data = s.pull('LAYER')\n        id1 = len(data)+1\n        params.insert(0,id1)\n        s.execute(params,'LAYER')\n        s.commit()\n        s.close()\n</code></pre>"},{"location":"Examples/Hybrid/","title":"Hybrid Characterization","text":"<p>Use a hybrid characterization method to identify parameters of the Johnson-Champoux-Allard model given data obtained from an impedance tube.</p> <pre><code>from acoustipy import AcousticTMM, AcousticID\n\n# Create an AcousticTMM object to generate toy impedance tube data\nstructure = AcousticTMM(incidence='Normal',air_temperature = 20)\n\n# Define the JCA and air gap material parameters for the toy data\nlayer1 = structure.Add_JCA_Layer(30, 46182,.917,2.1,83,128)\nair = structure.Add_Air_Layer(thickness = 100)\n\n# Generate rigid backed reflection data and save to a csv file\ns1 = structure.assemble_structure(layer1)\nA1 = structure.reflection(s1)\nstructure.to_csv('no_gap',A1)\n\n# Generate air backed reflection data and save to a csv file\ns2 = structure.assemble_structure(layer1,air)\nA2 = structure.reflection(s2)\nstructure.to_csv('gap',A2)\n\n# Create an AcousticID object, specifying to mount types, data files, and data types\ninv = AcousticID(mount_type='Dual',no_gap_file=\"no_gap.csv\",gap_file = \"gap.csv\",input_type='reflection',air_temperature=20)\n\n# Call the Hybrid method to find the tortuosity, viscous, and thermal characteristic lengths of the material\nres = inv.Hybrid(30,.917,air_gap=95,uncertainty = .15)\n\n# print the identified parameters\nprint(res)\n\n# Plot the absorption curves using the actual parameters vs those identified from the Indirect method\ninv.plot_comparison(res)\n\nres &gt;&gt;&gt; {'thickness': 29.982,\n         'flow resistivity': 46209.81,\n         'porosity': 0.918,\n         'tortuosity': 2.103,\n         'viscous characteristic length': 83.0,\n         'thermal characteristic length': 128.0,\n         'air gap': 100.0,\n         'error': 1.3018228618069009e-17}\n</code></pre> <p></p> <p></p>"},{"location":"Examples/Indirect/","title":"Indirect Characterization","text":"<p>Use an indirect characterization method to identify parameters of the Johnson-Champaux-Allard model given data obtained from an impedance tube.</p> <pre><code>from acoustipy import AcousticTMM, AcousticID\n\n# Create an AcousticTMM object to generate toy impedance tube data\nstructure = AcousticTMM(incidence='Normal',air_temperature = 20)\n\n# Define the JCA and air gap material parameters for the toy data\nlayer1 = structure.Add_JCA_Layer(30, 46182,.917,2.1,83,128)\nair = structure.Add_Air_Layer(thickness = 100)\n\n# Generate rigid backed reflection data and save to a csv file\ns1 = structure.assemble_structure(layer1)\nA1 = structure.reflection(s1)\nstructure.to_csv('no_gap',A1)\n\n# Generate air backed reflection data and save to a csv file\ns2 = structure.assemble_structure(layer1,air)\nA2 = structure.reflection(s2)\nstructure.to_csv('gap',A2)\n\n# Create an AcousticID object, specifying to mount types, data files, and data types\ninv = AcousticID(mount_type='Dual',no_gap_file=\"no_gap.csv\",gap_file = \"gap.csv\",air_temperature=20,input_type='reflection')\n\n# Call the Indirect method to find the flow resistivity, tortuosity, and viscous, and thermal characteristic lengths of the material\nres = inv.Indirect(30,.917,air_gap=100)\n\n# Plot the absorption curves using the actual parameters vs those identified from the Indirect method\ninv.plot_comparison(res)\n\n# print the identified parameters\nprint(res)\n\nres &gt;&gt; {'thickness': 30,\n        'flow resistivity': 46182.79193470273, \n        'porosity': 0.9326784023844896,\n        'tortuosity': 2.1373594528548225,\n        'viscous characteristic length': 83.16500367154856,\n        'thermal characteristic length': 115.12539138619321,\n        'air gap': 100}\n</code></pre> <p></p> <p></p>"},{"location":"Examples/Inverse/","title":"Inverse JCA Characterization","text":"<p>Use an inverse characterization method to identify parameters of the Johnson-Champaux-Allard model given data obtained from an impedance tube.</p> <pre><code>from acoustipy import acousticTMM, AcousticID\n\n# Create an AcousticTMM object to generate toy impedance tube data\nstructure = acousticTMM(incidence='Normal',air_temperature = 20)\n\n# Define the JCA and air gap material parameters for the toy data\nlayer1 = structure.Add_JCA_Layer(thickness = 30, flow_resistivity = 46879, porosity = .93, tortuosity = 1.7, viscous_characteristic_length = 80, thermal_characteristic_length = 105)\nair = structure.Add_Air_Layer(thickness = 375)\n\n# Generate rigid backed absorption data and save to a csv file\ns1 = structure.assemble_structure(layer1)\nA1 = structure.absorption(s1)\nstructure.to_csv('no_gap',A1)\n\n# Generate air backed absorption data and save to a csv file\ns2 = structure.assemble_structure(layer1,air)\nA2 = structure.absorption(s2)\nstructure.to_csv('gap',A2)\n\n# Create an AcousticID object, specifying to mount types, data files, and data types\ninv = AcousticID(mount_type='Dual',no_gap_file=\"no_gap.csv\", gap_file = 'gap.csv',air_temperature=20,input_type='absorption')\n\n# Call the Inverse method to find the tortuosity, viscous, and thermal characteristic lengths of the material\nres = inv.Inverse(30, 47000,.926,air_gap=375,uncertainty=.2,verbose=True)\n\n# Display summary statistics about the optimization\nstats = inv.stats(res)\nprint(stats)\n\n# Plot the results of the found parameters compared to the toy input data\ninv.plot_comparison(res)\n\n# Save the optimization results to a csv\ninv.to_csv(\"params.csv\",res)\n\nstats = {'slope': 1.000037058594857, 'intercept': 9.276088883464206e-05, 'r_value': 0.9999999674493408, 'p_value': 0.0, 'std_err': 8.732362148426126e-06}\n</code></pre> <p></p> <p></p>"},{"location":"Examples/impedance_tube/","title":"Using impedance tube data","text":"<p>Estimate the diffuse sound field absorption coefficients of a structure using the normal incidence reflection coefficients obtained via impedance tube. </p> <pre><code>from acoustipy import AcousticTMM\n\n# Generate synthetic \"impedance tube\" data\nstructure = AcousticTMM(incidence='Normal', air_temperature = 20)\n\n# Define the JCA and air gap material parameters for the synthetic data\nlayer1 = structure.Add_JCA_Layer(25.4, 60000, .91, 1.3, 85, 110)\nair = structure.Add_Air_Layer(thickness = 100)\n\n# Generate rigid backed reflection data and save to a csv file\ns1 = structure.assemble_structure(layer1)\nr1 = structure.reflection(s1)\nstructure.to_csv('no_gap_tube',r1)\n\n# Generate air backed absorption data and save to a csv file\ns2 = structure.assemble_structure(layer1,air)\nr2 = structure.reflection(s2)\nstructure.to_csv('gap_tube',r2)\n\n# Create a new structure to estimate the diffuse field absorption coefficients\nestimated_structure = AcousticTMM(incidence='Diffuse', air_temperature = 20)\n\n# Load the synthetic impedance tube data and define a new air layer\nestimated_layer = estimated_structure.Add_Layer_From_Tube(no_gap_file = 'no_gap_tube.csv', gap_file='gap_tube.csv', sample_thickness=25.4, air_gap_thickness=100)\nair2 = estimated_structure.Add_Air_Layer(thickness = 400)\n\n# Generate narrow band absorption data for the new structure\ns3 = estimated_structure.assemble_structure(estimated_layer,air2)\nabsorption = structure.absorption(s3)\n\n# Calculate the 3rd octave bands absorption coefficients\nbands = structure.octave_bands(absorption)\n\n# Calculate the four frequency average absorption\nffa_estimate = structure.FFA(bands)\nprint(ffa_estimate)\n\n&gt;&gt;&gt; 0.717\n\n# Compare the estimated FFA to that calculated from the original layer data\nair3 = structure.Add_Air_Layer(thickness = 400)\ns4 = structure.assemble_structure(layer1,air3)\nabs1 = structure.absorption(s4)\nbands1 = structure.octave_bands(abs1)\nffa_original = structure.FFA(bands1)\nprint(ffa_original)\n\n&gt;&gt;&gt; 0.717\n</code></pre>"},{"location":"Examples/layer_to_database/","title":"Saving layers to a database","text":"<p>Save the parameters of individual layers to a built-in SQLite database.</p> <pre><code>from acoustipy import AcousticTMM, AcoustiBase\n\n\nstructure = AcousticTMM(incidence='Normal',air_temperature = 20)\n\n# For each Add_XXX_Layer method, enable the save_layer parameter and give it a unique layer name\ndb = structure.Add_DB_Layer(25.4, 50000,save_layer=True,layer_name='test_DB')\ndbm = structure.Add_DBM_Layer(25.4, 50000,save_layer=True,layer_name='test_DBM')\njca = structure.Add_JCA_Layer(25.4, 50000,.90,1.2,80,110,save_layer=True,layer_name='test_JCA')\njcal = structure.Add_JCAL_Layer(25.4, 50000,.90,1.2,80,110,50,save_layer=True,layer_name='test_JCAL')\njcapl = structure.Add_JCAPL_Layer(25.4, 50000, .90, 1.2, 80, 110, 50, 70, 65,save_layer=True,layer_name='test_JCAPL')\nhoroshenkov = structure.Add_Horoshenkov_Layer(40, .90, 147, .325, save_layer=True, layer_name='test_horoshenkov')\nbiot_limp = structure.Add_Biot_Limp_Layer('JCA',25.4, 50000,200, .90, 1.2, 80, 110,save_layer=True,layer_name='test_biot_limp')\nbiot_rigid = structure.Add_Biot_Rigid_Layer('JCA',25.4, 50000,200, .90, 1.2, 80, 110,save_layer=True,layer_name='test2_biot_rigid')\nscreen = structure.Add_Resistive_Screen(2.54, 50000, .90,save_layer=True,layer_name='test_screen')\nmaa = structure.Add_MAA_MPP_Layer(2.54, .5, 1,save_layer=True,layer_name='test_maa_mpp')\nef_mpp = structure.Add_MPP_EF_Layer(2.54, .5, 1,save_layer=True,layer_name='test_ef_mpp')\n\n# Pull the layer information from the database and save to a .csv file\ns = AcoustiBase()\ns.summarize_layers()\n</code></pre>"},{"location":"Examples/layers_from_database/","title":"Load layers from a database","text":"<p>Load the previously saved layers from the database and calculate the transmission loss of one of the layers.</p> <p><pre><code>from acoustipy import AcousticTMM\n\nstructure = AcousticTMM(incidence='Normal',air_temperature = 20)\n\n# Add layers from the database\ndb = structure.Add_Layer_From_Database('test_DB')\ndbm = structure.Add_Layer_From_Database('test_DBM')\njca = structure.Add_Layer_From_Database('test_JCA')\njcal = structure.Add_Layer_From_Database('test_JCAL')\njcapl = structure.Add_Layer_From_Database('test_JCAPL')\nhoroshenkov = structure.Add_Layer_From_Database('test_horoshenkov')\nbiot_limp = structure.Add_Layer_From_Database('test_biot_limp')\nbiot_rigid = structure.Add_Layer_From_Database('test2_biot_rigid')\nscreen = structure.Add_Layer_From_Database('test_screen')\nmaa = structure.Add_Layer_From_Database('test_maa_mpp')\nef_mpp = structure.Add_Layer_From_Database('test_ef_mpp')\n\n# Calculate th narrow band transmission coefficients for the JCA layer\ns = structure.assemble_structure(jca)\ntl = structure.transmission_loss(s)\n\n# Plot the transmission coefficients\nstructure.plot_curve([tl])\n</code></pre> </p> <p></p>"},{"location":"Examples/multilayer_structure/","title":"Characterize a multilayer structure","text":"<p>Calculate the absorption coefficients of a multilayer structure and plot the narrow  and 3rd octave bands using matplotlib.</p> <pre><code>from acoustipy import AcousticTMM\n\n# Create an AcousticTMM object, specifying a diffuse sound field at 20C\nstructure = AcousticTMM(incidence='Diffuse',air_temperature=20)\n\n# Define the layers of the material using various models\nlayer1 = structure.Add_Resistive_Screen(thickness=1,flow_resistivity=100000,porosity=.86)\nlayer2 = structure.Add_DBM_Layer(thickness = 25.4,flow_resistivity=60000)\nlayer3 = structure.Add_Resistive_Screen(thickness = 1, flow_resistivity=500000,porosity=.75)\n\n# Specify the material backing condition -- in this case a 400mm air gap\nair = structure.Add_Air_Layer(thickness = 400)\n\n# Build the total transfer matrix of the structure + air gap\ntransfer_matrix = structure.assemble_structure(layer1,layer2,layer3,air)\n\n# Calculate the frequency dependent narrow band absorption coefficients\nabsorption = structure.absorption(transfer_matrix)\n\n# Calculate the 3rd octave bands absorption coefficients\nbands = structure.octave_bands(absorption)\n\n# Calculate the four frequency average absorption\nFFA = structure.FFA(bands)\n\n# Plot and display the narrow and 3rd band coefficients on the same figure\nstructure.plot_curve([absorption,bands],[\"absorption\",\"third octave\"])\n</code></pre> <p></p> <p></p>"},{"location":"Examples/structure_to_database/","title":"Saving structures to a database","text":"<p>Save a structure consisting of mulitple layers to a built-in SQLite database</p> <pre><code>from acoustipy import AcousticTMM, AcoustiBase\n\ns = AcousticTMM(incidence='Diffuse',air_temperature=20)\n\n# Define a arbitrary structure made of a porous DBM layer sandwhiched between 2 porous screens\nlayer1 = s.Add_Resistive_Screen(thickness=1,flow_resistivity=100000,porosity=.86,save_layer=True,layer_name='test_screen1')\nlayer2 = s.Add_DBM_Layer(thickness = 25.4,flow_resistivity=60000,save_layer=True,layer_name='test_DBM')\nlayer3 = s.Add_Resistive_Screen(thickness = 1, flow_resistivity=500000,porosity=.75,save_layer=True,layer_name='test_screen2')\nair = s.Add_Air_Layer(thickness = 400,save_layer=True,layer_name='test_AIR')\n\n# Save the structure to the database\nstructure = s.assemble_structure(layer1,layer2,layer3,air,save_structure=True,structure_name='test')\n\n# Load the structure from the database\ns2 = s.assemble_from_database('test')\n\n# Compare the narrow band absorption curves from the original structure and the one loaded from the database\nabs1 = s.absorption(structure)\nabsorption = s.absorption(s2)\n\ns.plot_curve([absorption,abs1],['From Database','Original'])\n\n# Pull the information from the database and save to .csv files\nst = AcoustiBase()\nst.summarize_layers()\nst.summarize_structures()\n</code></pre> <p></p> <p></p>"},{"location":"Theory/Absorption_Theory/","title":"Absorption","text":"<p>The frequency-dependent absorption coefficients \\((A)\\) are calculated directly from the total transfer matrix \\((T_{t})\\) of a multilayered structure.  These coefficients are a measure of the amount of sound energy absorbed by the structure.</p> <p>The coefficients can be calculated under both normal and diffuse sound field conditions.  Under a normal incidence sound field, the sound impinges on the surface from a single, perpendicular angle.  In the diffuse field case, the incident sound theoretically strikes the surface of the material from all possible angles -- though the acoustipy implementation defaults to angles between 0 and 79, as seen in literature on the topic.</p> <p>The acoustipy implementation for both cases can be found here.</p>"},{"location":"Theory/Absorption_Theory/#normal-incidence","title":"Normal Incidence","text":"<p>Starting from the total transfer matrix:</p> \\[ T_{t} =  \\begin{bmatrix} T_{11} &amp; T_{12}\\\\ T_{21} &amp; T_{22} \\\\ \\end{bmatrix} \\] <p>First, the surface impedence \\((Z_{s})\\) is calculated:</p> \\[ Z_{s} = \\frac{T_{11}}{T_{21}}   \\] <p>Then the reflection coefficients are:</p> \\[ R = \\frac{Z_{s}-Z_{0}}{Z_{s}-Z_{0}}   \\] <p>where \\(Z_{0}\\) is the characteristic impedence of air:</p> \\[ Z_{0} = \\rho_{0} c_{0} \\] <p>and \\(\\rho_{0}\\) is the density of air and \\(c_{0}\\) is the speed of sound in air.</p> <p>Finally, the absorption coefficients are detemined via:</p> \\[ A = 1-|R|^2   \\]"},{"location":"Theory/Absorption_Theory/#diffuse-incidence","title":"Diffuse Incidence","text":"<p>Under the diffuse sound field condition, the calculation of surface impedence \\((Z_{s})\\) is the same as the normal incidence condition.</p> <p>The reflection coefficients at each angle are then:</p> \\[ r = \\frac{Z_{s}\\cos(\\theta)-Z_{0}}{Z_{s}\\cos(\\theta)+Z_{0}} \\] <p>Similar to the normal field condition, the absorption coefficients at each angle are then:</p> \\[ a = 1-|r|^2   \\] <p>which yields a vector of shape \\([f, \\theta]\\).  To collapse this vector to shape \\([f,1]\\), Paris' formula is used as shown below.</p> \\[ A = \\frac{\\sum a\\cos(\\theta)\\sin(\\theta)}{\\sum \\cos(\\theta)\\sin(\\theta)} \\]"},{"location":"Theory/Biot_Limp_Model/","title":"Biot-Limp Model","text":"<p>The Biot-Limp model modifies the dynamic mass density \\((\\tilde{\\rho}_{eq})\\) determined via an equivalent fluid model such as: DB, DBM, JCA, JCAL, and JCAPL.</p> <p>The acoustipy implementation follows from eq. 24 in B\u00e9cot and Jaouen.</p> \\[ \\frac{1}{\\tilde{\\rho}_{limp}} = \\frac{1}{\\phi\\tilde{\\rho}_{eq}}+\\frac{\\gamma^2}{\\phi\\tilde{\\rho}} \\] <p>where \\(\\gamma\\) and \\(\\tilde{\\rho}\\) are defined as:</p> \\[ \\gamma = \\frac{\\rho_{0}}{\\tilde{\\rho}_{eq}}-1 \\] \\[ \\tilde{\\rho} = \\rho_{1}+\\phi\\rho_{0}-\\frac{\\rho_{0}^2}{\\tilde{\\rho}_{eq}} \\] <p>The Add_Biot_Limp_Layer method then converts The modified dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}_{limp}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}_{limp}}{\\widetilde{K}}} \\]"},{"location":"Theory/Biot_Limp_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/Biot_Limp_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{1} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{volumetric density} \\] <p>The following parameters are used to find the dynamic mass density \\((\\tilde{\\rho}_{eq})\\) from the specified equivalent fluid model.</p> \\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\] \\[ k_{0}^{\\prime} = \\Bigg[m^2\\Bigg]\\tag{thermal permeability} \\] \\[ \\alpha_{0}^{\\prime} = \\Bigg[unitless\\Bigg]\\tag{thermal tortuosity} \\] \\[ \\alpha_{0} = \\Bigg[unitless\\Bigg]\\tag{viscous tortuosity} \\]"},{"location":"Theory/Biot_Limp_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/Biot_Limp_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\]"},{"location":"Theory/Biot_Rigid_Model/","title":"Biot-Rigid Model","text":"<p>The Biot-Rigid model modifies the dynamic mass density \\((\\tilde{\\rho}_{eq})\\) determined via an equivalent fluid model such as: DB, DBM, JCA, JCAL, and JCAPL.</p> <p>The acoustipy implementation follows from eq. 23 in B\u00e9cot and Jaouen.</p> \\[ \\frac{1}{\\tilde{\\rho}_{rigid}} = \\frac{1}{\\phi\\tilde{\\rho}_{eq}}+\\frac{\\gamma^2}{\\phi\\tilde{\\rho}}+\\frac{(1-\\phi)}{\\phi}\\frac{\\gamma}{\\tilde{\\rho}} \\] <p>where \\(\\gamma\\) and \\(\\tilde{\\rho}\\) are defined as:</p> \\[ \\gamma = \\frac{\\rho_{0}}{\\tilde{\\rho}_{eq}}-1 \\] \\[ \\tilde{\\rho} = \\rho_{1}+\\phi\\rho_{0}-\\frac{\\rho_{0}^2}{\\tilde{\\rho}_{eq}} \\] <p>The Add_Biot_Rigid_Layer method then converts The modified dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}_{rigid}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}_{rigid}}{\\widetilde{K}}} \\]"},{"location":"Theory/Biot_Rigid_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/Biot_Rigid_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{1} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{volumetric density} \\] <p>The following parameters are used to find the dynamic mass density \\((\\tilde{\\rho}_{eq})\\) from the specified equivalent fluid model.</p> \\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\] \\[ k_{0}^{\\prime} = \\Bigg[m^2\\Bigg]\\tag{thermal permeability} \\] \\[ \\alpha_{0}^{\\prime} = \\Bigg[unitless\\Bigg]\\tag{thermal tortuosity} \\] \\[ \\alpha_{0} = \\Bigg[unitless\\Bigg]\\tag{viscous tortuosity} \\]"},{"location":"Theory/Biot_Rigid_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/Biot_Rigid_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\]"},{"location":"Theory/DBM_Model/","title":"Delaney-Bazley-Miki Model","text":"<p>The Delaney-Bazley-Mike model is an empirical, one parameter  model consisting of the static airflow resistivity \\((\\sigma)\\) of the porous material.  It is generally considered a better fit of the data from Delaney-Bazley.</p> <p>The equations for the complex characteristic impedance \\((Z_{c})\\) and wavenumber \\((k_{c})\\) can be found below:</p> \\[ Z_{c} = \\rho_{0}c_{0}\\Bigg[ 1+0.0699\\left(\\frac{f}{\\sigma}\\right)^{-0.632}-j0.107\\left(\\frac{f}{\\sigma}\\right)^{-0.632} \\Bigg] \\] \\[ k_{c} = \\frac{\\omega}{c_{0}}\\Bigg[ 1 + 0.109\\left(\\frac{f}{\\sigma}\\right)^{-0.618} - j 0.160\\left(\\frac{f}{\\sigma}\\right)^{-0.618}\\Bigg] \\] <p>As with the Delaney-Bazley Model, the acoustipy implementation converts the characteristic impedence and wavenumber to the dynamic mass density \\((\\tilde{\\rho})\\) and dynamic bulk modulus \\((\\widetilde{K})\\) via the equations below, as the Add_DBM_Layer method calls the internal _calc_dynamics method for consistency with the other equivalent fluid models.</p> \\[ \\tilde{\\rho} = \\frac{Z_{c}k_{c}}{\\omega} \\] \\[ \\widetilde{K} = \\frac{{\\omega}Z_{c}}{k_{c}} \\] <p>The dynamic mass density and bulk modulus are then converted back to the characteristic impedence and wavenumber for use in the layer transfer matrix via:</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\] <p>The model is valid in the frequency range defined below:</p> \\[ 0.01 &lt; {\\frac{f}{\\sigma}} &lt; 1.00 \\]"},{"location":"Theory/DBM_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/DBM_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\]"},{"location":"Theory/DBM_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/DBM_Model/#using-the-following-nomenclature-symbol-units-name-or-symbol-equation-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name) or Symbol = equation = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ f = \\Bigg[Hz\\Bigg]\\tag{linear frequency} \\] \\[ \\omega = 2{\\pi}f = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\]"},{"location":"Theory/DB_Model/","title":"Delaney-Bazley Model","text":"<p>The Delaney-Bazley model is an empirical, one parameter model consisting of the static airflow resistivity \\((\\sigma)\\) of the porous material.</p> <p>The equations for the complex characteristic impedance \\((Z_{c})\\) and wavenumber \\((k_{c})\\) can be found below:</p> \\[ Z_{c} = \\rho_{0}c_{0}\\Bigg[ 1+0.0571\\left(\\frac{\\rho_{0}f}{\\sigma}\\right)^{-0.754}-j0.0870\\left(\\frac{\\rho_{0}f}{\\sigma}\\right)^{-0.732}\\Bigg] \\] \\[ k_{c} = \\frac{\\omega}{c_{0}}\\Bigg[1+0.0978\\left(\\frac{\\rho_{0}f}{\\sigma}\\right)^{-0.700}-j0.1890\\left(\\frac{\\rho_{0}f}{\\sigma}\\right)^{-0.595}\\Bigg] \\] <p>In the acoustipy implementation, the characteristic impedence and wavenumber are converted to the dynamic mass density \\((\\tilde{\\rho})\\) and dynamic bulk modulus \\((\\widetilde{K})\\) via the equations below, as the Add_DB_Layer method calls the internal _calc_dynamics method for consistency with the other equivalent fluid models.</p> \\[ \\tilde{\\rho} = \\frac{Z_{c}k_{c}}{\\omega} \\] \\[ \\widetilde{K} = \\frac{{\\omega}Z_{c}}{k_{c}} \\] <p>The dynamic mass density and bulk modulus are then converted back to the characteristic impedence and wavenumber for use in the layer transfer matrix via:</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\] <p>The model is valid in the frequency range defined below:</p> \\[ 0.01 &lt; {\\frac{f}{\\sigma}} &lt; 1.00 \\]"},{"location":"Theory/DB_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/DB_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\]"},{"location":"Theory/DB_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/DB_Model/#using-the-following-nomenclature-symbol-units-name-or-symbol-equation-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name) or Symbol = equation = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ f = \\Bigg[Hz\\Bigg]\\tag{linear frequency} \\] \\[ \\omega = 2{\\pi}f = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\]"},{"location":"Theory/EF_MPP_Model/","title":"Equivalent Fluid MPP Model","text":"<p>The equivalent fluid microperforate model estimates the input parameters to the JCA model based on the perforate diameter \\((d)\\), center-to-center distance \\((b)\\), and thickness \\((t)\\).</p> <p>The internal _calc_dynamics method is then used to determine the dynamic mass density \\((\\tilde{\\rho})\\) and dynamic bulk modulus \\((\\widetilde{K})\\) using the JCA model.</p>"},{"location":"Theory/EF_MPP_Model/#estimation-of-jca-parameters","title":"Estimation of JCA parameters","text":"\\[ \\phi = \\frac{\\pi}{4}\\Bigg(\\frac{d}{b}\\Bigg)^2 \\] \\[ \\sigma = \\frac{32\\eta}{\\phi d^2} \\] \\[ \\Lambda = \\frac{d}{2} \\] \\[ \\Lambda^{\\prime} = \\frac{d}{2} \\] \\[ \\tau = 1+\\frac{2*fok}{t} \\] <p>where \\(fok\\) is:</p> \\[ fok = \\frac{4d}{3\\pi}(1-1.13eps-0.09eps^2+0.27eps^3) \\] <p>and \\(eps\\) is:</p> \\[ eps = 2\\sqrt{\\frac{\\phi}{\\pi}} \\] <p>The Add_MPP_EF_Layer method then converts the modified dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/EF_MPP_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/EF_MPP_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":""},{"location":"Theory/EF_MPP_Model/#model-specific","title":"Model Specific","text":"\\[ d = \\Bigg[m\\Bigg]\\tag{perforate diameter} \\] \\[ b = \\Bigg[m\\Bigg]\\tag{center-to-center distance} \\] \\[ t = \\Bigg[m\\Bigg]\\tag{layer thickness} \\]"},{"location":"Theory/EF_MPP_Model/#jca-parameters","title":"JCA Parameters","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\]"},{"location":"Theory/EF_MPP_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/EF_MPP_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\]"},{"location":"Theory/Horoshenkov_Model/","title":"Horoshenkov Model","text":"<p>The Horoshenkov model consists of three parameters -- the porosity \\((\\phi)\\), median pore size \\((\\bar s)\\), and pore size distribution \\((\\sigma_{s})\\).</p> <p>From these three parameters, the rest of the JCAL parameters -- the static airflow resistivity \\((\\sigma)\\), porosity \\((\\phi)\\), tortuosity \\((\\tau)\\), viscous characteristic length \\((\\Lambda)\\), thermal characteristic length \\((\\Lambda^\\prime)\\), and thermal permeability \\((k_{0}^\\prime)\\) -- can be calculated as seen below:</p> \\[ \\tau = \\exp\\Bigg(4[\\sigma_{s}ln(2)]^2\\Bigg) \\] \\[ \\sigma = \\frac{8\\eta\\tau}{\\phi{\\bar s^2}}\\exp\\Bigg(6[\\sigma_{s}ln(2)]^2\\Bigg) \\] \\[ \\Lambda = \\bar s \\exp\\Bigg(-\\frac{5}{2}[\\sigma_{s}ln(2)]^2\\Bigg) \\] \\[ \\Lambda^\\prime = \\bar s \\exp\\Bigg(\\frac{3}{2}[\\sigma_{s}ln(2)]^2\\Bigg) \\] \\[ k_{0}^\\prime = \\frac{\\phi{\\bar s^2}}{8\\tau}\\exp\\Bigg(-6[\\sigma_{s}ln(2)]^2\\Bigg) \\] <p>The dynamic mass density and bulk modulus are then determined within the _calc_dynamics method using the calculated JCAL parameters, following the implemention found here: JCAL.</p> <p>The Add_Horoshenkov_Layer method then converts The dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/Horoshenkov_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/Horoshenkov_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\bar s = \\Bigg[{\\mu}m\\Bigg]\\tag{median pore size} \\] \\[ \\sigma_{s} = \\Bigg[unitless\\Bigg]\\tag{pore size distribution} \\]"},{"location":"Theory/Horoshenkov_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/Horoshenkov_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\]"},{"location":"Theory/JCAL_Model/","title":"JCAL Model","text":"<p>The Johnson-Champoux-Allard-Lafarge model is a six parameter model consisting of the static airflow resistivity \\((\\sigma)\\), porosity \\((\\phi)\\), tortuosity \\((\\tau)\\), viscous characteristic length \\((\\Lambda)\\), thermal characteristic length \\((\\Lambda^\\prime)\\), and thermal permeability \\((k_{0}^\\prime)\\).</p> <p>The acoustipy implementation for the JCA, JCAL, and JCAPL models are all based on the implementation from APMR.  The equations described below can be found in the _calc_dynamics method.</p>"},{"location":"Theory/JCAL_Model/#dynamic-mass-density","title":"Dynamic Mass Density","text":"\\[ \\tilde{\\rho} = \\frac{\\rho_{0}\\tilde{\\alpha}(\\omega)}{\\phi} \\] \\[ \\tilde{\\alpha}(\\omega) = \\tau\\Bigg[1+\\frac{\\tilde{F}(\\omega)}{j\\bar{\\omega}}\\Bigg] \\] \\[ \\tilde{F}(\\omega) = 1-P+P\\sqrt{1+\\frac{M}{2P^2}j\\bar{\\omega}} \\] \\[ \\bar{\\omega} = \\frac{{\\omega}{\\rho_{0}}{\\tau}}{{\\sigma}{\\phi}} \\] \\[ M = \\frac{8{\\eta}{\\tau}}{{\\sigma}{\\phi}{\\Lambda}^2} \\] \\[ P = 1 \\]"},{"location":"Theory/JCAL_Model/#dynamic-bulk-modulus","title":"Dynamic Bulk Modulus","text":"\\[ \\widetilde{K} = \\frac{{\\gamma}P_{0}}{{\\phi}\\tilde{\\beta}(\\omega)} \\] \\[ \\tilde{\\beta}(\\omega) = \\gamma-(\\gamma - 1)\\Bigg[1+\\frac{\\tilde{F^{\\prime}}(\\omega)}{j\\bar{\\omega^\\prime}}\\Bigg]^{-1} \\] \\[ \\tilde{F^{\\prime}}(\\omega) = 1-P^{\\prime}+P^{\\prime}\\sqrt{1+\\frac{M^{\\prime}}{2P^{\\prime{2}}}j\\bar{\\omega^{\\prime}}} \\] \\[ \\bar{\\omega^{\\prime}} = \\frac{{\\omega}{\\rho_{0}}{Pr}{k_{0}^\\prime}}{{\\eta}{\\phi}} \\] \\[ M^{\\prime} = \\frac{8{k_{0}^\\prime}}{{\\phi}{\\Lambda^{\\prime{2}}}} \\] \\[ P^{\\prime} = 1 \\] <p>The Add_JCAL_Layer method then converts The dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/JCAL_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/JCAL_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\] \\[ k_{0}^{\\prime} = \\Bigg[m^2\\Bigg]\\tag{thermal permeability} \\]"},{"location":"Theory/JCAL_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/JCAL_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ \\omega = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\] \\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\] \\[ \\Pr = \\Bigg[unitless\\Bigg]\\tag{Prandtl Number} \\]"},{"location":"Theory/JCAPL_Model/","title":"JCAPL Model","text":"<p>The Johnson-Champoux-Allard-Pride-Lafarge model is an eight parameter model consisting of the static airflow resistivity \\((\\sigma)\\), porosity \\((\\phi)\\), tortuosity \\((\\tau)\\), viscous characteristic length \\((\\Lambda)\\), thermal characteristic length \\((\\Lambda^\\prime)\\), thermal permeability \\((k_{0}^\\prime)\\), thermal tortuosity \\((\\alpha_{0}^\\prime)\\), and viscous tortuosity \\((\\alpha_{0})\\).</p> <p>The acoustipy implementation for the JCA, JCAL, and JCAPL models are all based on the implementation from APMR.  The equations described below can be found in the _calc_dynamics method.</p>"},{"location":"Theory/JCAPL_Model/#dynamic-mass-density","title":"Dynamic Mass Density","text":"\\[ \\tilde{\\rho} = \\frac{\\rho_{0}\\tilde{\\alpha}(\\omega)}{\\phi} \\] \\[ \\tilde{\\alpha}(\\omega) = \\tau\\Bigg[1+\\frac{\\tilde{F}(\\omega)}{j\\bar{\\omega}}\\Bigg] \\] \\[ \\tilde{F}(\\omega) = 1-P+P\\sqrt{1+\\frac{M}{2P^2}j\\bar{\\omega}} \\] \\[ \\bar{\\omega} = \\frac{{\\omega}{\\rho_{0}}{\\tau}}{{\\sigma}{\\phi}} \\] \\[ M = \\frac{8{\\eta}{\\tau}}{{\\sigma}{\\phi}{\\Lambda}^2} \\] \\[ P = \\frac{M}{4\\Bigg(\\frac{\\alpha_{0}}{\\tau}-1\\Bigg)} \\]"},{"location":"Theory/JCAPL_Model/#dynamic-bulk-modulus","title":"Dynamic Bulk Modulus","text":"\\[ \\widetilde{K} = \\frac{{\\gamma}P_{0}}{{\\phi}\\tilde{\\beta}(\\omega)} \\] \\[ \\tilde{\\beta}(\\omega) = \\gamma-(\\gamma - 1)\\Bigg[1+\\frac{\\tilde{F^{\\prime}}(\\omega)}{j\\bar{\\omega^\\prime}}\\Bigg]^{-1} \\] \\[ \\tilde{F^{\\prime}}(\\omega) = 1-P^{\\prime}+P^{\\prime}\\sqrt{1+\\frac{M^{\\prime}}{2P^{\\prime{2}}}j\\bar{\\omega^{\\prime}}} \\] \\[ \\bar{\\omega^{\\prime}} = \\frac{{\\omega}{\\rho_{0}}{Pr}{k_{0}^\\prime}}{{\\eta}{\\phi}} \\] \\[ M^{\\prime} = \\frac{8{k_{0}^\\prime}}{{\\phi}{\\Lambda^{\\prime{2}}}} \\] \\[ P^{\\prime} = \\frac{M^\\prime}{4\\Bigg(\\alpha_{0}^\\prime-1\\Bigg)} \\] <p>The Add_JCAPL_Layer method then converts The dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/JCAPL_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/JCAPL_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\] \\[ k_{0}^{\\prime} = \\Bigg[m^2\\Bigg]\\tag{thermal permeability} \\] \\[ \\alpha_{0}^{\\prime} = \\Bigg[unitless\\Bigg]\\tag{thermal tortuosity} \\] \\[ \\alpha_{0} = \\Bigg[unitless\\Bigg]\\tag{viscous tortuosity} \\]"},{"location":"Theory/JCAPL_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/JCAPL_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ \\omega = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\] \\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\] \\[ \\Pr = \\Bigg[unitless\\Bigg]\\tag{Prandtl Number} \\]"},{"location":"Theory/JCA_Model/","title":"JCA Model","text":"<p>The Johnson-Champoux-Allard model is a five parameter model consisting of the static airflow resistivity \\((\\sigma)\\), porosity \\((\\phi)\\), tortuosity \\((\\tau)\\), viscous characteristic length \\((\\Lambda)\\) and thermal characteristic length \\((\\Lambda^\\prime)\\).</p> <p>The acoustipy implementation for the JCA, JCAL, and JCAPL models are all based on the implementation from APMR.</p> <p>Note that for the JCA acoustipy implementation, found in the _calc_dynamics method, the \\(\\bar\\omega^\\prime\\) term differs from the reference implementation as seen below.</p>"},{"location":"Theory/JCA_Model/#dynamic-mass-density","title":"Dynamic Mass Density","text":"\\[ \\tilde{\\rho} = \\frac{\\rho_{0}\\tilde{\\alpha}(\\omega)}{\\phi} \\] \\[ \\tilde{\\alpha}(\\omega) = \\tau\\Bigg[1+\\frac{\\tilde{F}(\\omega)}{j\\bar{\\omega}}\\Bigg] \\] \\[ \\tilde{F}(\\omega) = 1-P+P\\sqrt{1+\\frac{M}{2P^2}j\\bar{\\omega}} \\] \\[ \\bar{\\omega} = \\frac{{\\omega}{\\rho_{0}}{\\tau}}{{\\sigma}{\\phi}} \\] \\[ M = \\frac{8{\\eta}{\\tau}}{{\\sigma}{\\phi}{\\Lambda}^2} \\] \\[ P = 1 \\]"},{"location":"Theory/JCA_Model/#dynamic-bulk-modulus","title":"Dynamic Bulk Modulus","text":"\\[ \\widetilde{K} = \\frac{{\\gamma}P_{0}}{{\\phi}\\tilde{\\beta}(\\omega)} \\] \\[ \\tilde{\\beta}(\\omega) = \\gamma-(\\gamma - 1)\\Bigg[1+\\frac{\\tilde{F^{\\prime}}(\\omega)}{j\\bar{\\omega^\\prime}}\\Bigg]^{-1} \\] \\[ \\tilde{F^{\\prime}}(\\omega) = 1-P^{\\prime}+P^{\\prime}\\sqrt{1+\\frac{M^{\\prime}}{2P^{\\prime{2}}}j\\bar{\\omega^{\\prime}}} \\] \\[ \\bar{\\omega^{\\prime}} = \\frac{{\\omega}{\\rho_{0}}{Pr}{\\Lambda^{\\prime{2}}}}{8{\\eta}} \\] \\[ M^{\\prime} = 1 \\] \\[ P^{\\prime} = 1 \\] <p>The Add_JCA_Layer method then converts The dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/JCA_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/JCA_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\] \\[ \\tau = \\Bigg[unitless\\Bigg]\\tag{tortuosity} \\] \\[ \\Lambda = \\Bigg[{\\mu}m\\Bigg]\\tag{viscous characteristic length} \\] \\[ \\Lambda^{\\prime} = \\Bigg[{\\mu}m\\Bigg]\\tag{thermal characteristic length} \\]"},{"location":"Theory/JCA_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/JCA_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ \\omega = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\] \\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\] \\[ \\Pr = \\Bigg[unitless\\Bigg]\\tag{Prandtl Number} \\]"},{"location":"Theory/MAA_MPP_Model/","title":"MAA MPP Model","text":"<p>The Maa microperforate model determines the characteristic impedence \\((Z_{c})\\) of the layer based on the perforate diameter \\((d)\\), center-to-center distance \\((b)\\), and thickness \\((t)\\).</p> <p>Unlike other material models, the Maa MPP model does not calculate a characteristic wavenumber \\((k_{c})\\).  Instead, a separate transfer matrix is used.</p>"},{"location":"Theory/MAA_MPP_Model/#determination-of-characteristic-impedence","title":"Determination of Characteristic Impedence","text":"\\[ Z_{c} = r+j\\omega m \\] <p>where \\(r\\) is:</p> \\[ r = \\frac{32\\eta t}{\\phi d^2} r_{1} \\] \\[ r_{1} = \\sqrt{1+\\frac{x^2}{32}}+\\frac{\\sqrt{2}}{32} x \\frac{d}{t} \\] <p>\\(m\\) is:</p> \\[ m = \\frac{\\rho_{0}t}{\\phi} m_{1} \\] \\[ m_{1} = 1+\\frac{1}{\\sqrt{1+\\frac{x^2}{2}}}+\\frac{0.85d}{t} \\] <p>and </p> \\[ x = \\frac{d}{2}\\sqrt{\\frac{\\omega\\rho_{0}}{\\eta}} \\] \\[ \\phi = \\frac{\\pi}{4}\\Bigg(\\frac{d}{b}\\Bigg)^2 \\] <p>The characteristic impedence \\((Z_{c})\\) is then used directly in the layer transfer matrix via the Add_MAA_MPP_Layer method.</p>"},{"location":"Theory/MAA_MPP_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/MAA_MPP_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ d = \\Bigg[m\\Bigg]\\tag{perforate diameter} \\] \\[ b = \\Bigg[m\\Bigg]\\tag{center-to-center distance} \\] \\[ t = \\Bigg[m\\Bigg]\\tag{layer thickness} \\]"},{"location":"Theory/MAA_MPP_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/MAA_MPP_Model/#using-the-following-nomenclature-symbol-units-name_1","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ \\eta = \\Bigg[Pa*s\\Bigg]\\tag{viscosity of air} \\] \\[ \\omega = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\]"},{"location":"Theory/Reflection_Theory/","title":"Reflection","text":"<p>The frequency-dependent reflection coefficients \\((R)\\) are calculated directly from the total transfer matrix \\((T_{t})\\) of a multilayered structure.  These coefficients are a measure of how much sound is reflected off the surface of a structure.</p> <p>The coefficients can be calculated under both normal and diffuse sound field conditions.  Under a normal incidence sound field, the sound impinges on the surface from a single, perpendicular angle.  In the diffuse field case, the incident sound theoretically strikes the surface of the material from all possible angles -- though the acoustipy implementation defaults to angles between 0 and 79, as seen in literature on the topic.</p> <p>The acoustipy implementation for both cases can be found here.</p>"},{"location":"Theory/Reflection_Theory/#normal-incidence","title":"Normal Incidence","text":"<p>Starting from the total transfer matrix:</p> \\[ T_{t} =  \\begin{bmatrix} T_{11} &amp; T_{12}\\\\ T_{21} &amp; T_{22} \\\\ \\end{bmatrix} \\] <p>First, the surface impedence \\((Z_{s})\\) is calculated:</p> \\[ Z_{s} = \\frac{T_{11}}{T_{21}}   \\] <p>Then the reflection coefficients are:</p> \\[ R = \\frac{Z_{s}-Z_{0}}{Z_{s}-Z_{0}}   \\] <p>where \\(Z_{0}\\) is the characteristic impedence of air:</p> \\[ Z_{0} = \\rho_{0} c_{0} \\] <p>and \\(\\rho_{0}\\) is the density of air and \\(c_{0}\\) is the speed of sound in air.</p>"},{"location":"Theory/Reflection_Theory/#diffuse-incidence","title":"Diffuse Incidence","text":"<p>Under the diffuse sound field condition, the calculation of surface impedence \\((Z_{s})\\) is the same as the normal incidence condition.</p> <p>The reflection coefficients at each angle are then:</p> \\[ r = \\frac{Z_{s}\\cos(\\theta)-Z_{0}}{Z_{s}\\cos(\\theta)+Z_{0}} \\] <p>which yields a vector of shape \\([f, \\theta]\\).  To collapse this vector to shape \\([f,1]\\), Paris' formula is used as shown below.</p> \\[ R = \\frac{\\sum r\\cos(\\theta)\\sin(\\theta)}{\\sum \\cos(\\theta)\\sin(\\theta)} \\]"},{"location":"Theory/Resistive_Screen_Model/","title":"Resistive Screen Model","text":"<p>The Resistive Screen model implemented in acoustipy is from the paper below, neglecting the frame mechanical properties:</p> <p>Mathieu Gaborit, Olivier Dazel, Peter G\u00f6ransson; A simplified model for thin acoustic screens. J. Acoust. Soc. Am. 1 July 2018; 144 (1): EL76\u2013EL81. https://doi.org/10.1121/1.5047929</p> <p>The equations for the dynamic mass density \\((\\tilde{\\rho})\\) and dynamic bulk modulus \\((\\widetilde{K})\\) can be found below:</p> \\[ \\tilde{\\rho} = \\frac{\\rho_{0}}{\\phi}+\\frac{\\sigma}{j{\\omega}} \\] \\[ \\widetilde{K} = \\frac{P_{0}}{\\phi} \\] <p>The Add_Resistive_Screen method then converts The dynamic mass density and bulk modulus to the characteristic impedence \\((Z_{c})\\) and wavenumber \\((k_{c})\\) for use in the layer transfer matrix.</p> \\[ Z_{c} = \\sqrt{\\tilde{\\rho}\\widetilde{K}} \\] \\[ k_{c} = {\\omega}\\sqrt{\\frac{\\tilde{\\rho}}{\\widetilde{K}}} \\]"},{"location":"Theory/Resistive_Screen_Model/#model-parameters","title":"Model Parameters:","text":""},{"location":"Theory/Resistive_Screen_Model/#using-the-following-nomenclature-symbol-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name)","text":"\\[ \\sigma = \\Bigg[\\frac{Pa*s}{m^2}\\Bigg]\\tag{static airflow resistivity} \\] \\[ \\phi = \\Bigg[unitless\\Bigg]\\tag{porosity} \\]"},{"location":"Theory/Resistive_Screen_Model/#defining-other-symbols","title":"Defining Other Symbols:","text":""},{"location":"Theory/Resistive_Screen_Model/#using-the-following-nomenclature-symbol-units-name-or-symbol-equation-units-name","title":"Using the following nomenclature --- Symbol = [Units] (name) or Symbol = equation = [Units] (name)","text":"\\[   \\rho_{0} = \\Bigg[\\frac{kg}{m^3}\\Bigg]\\tag{air density} \\] \\[ \\omega = 2{\\pi}f = \\Bigg[\\frac{radians}{s}\\Bigg]\\tag{angular frequency} \\]"},{"location":"Theory/TMM_Theory/","title":"Transfer Matrix Method","text":"<p>Three types of 2x2 transfer matrices are used to characterize porous materials \\((T_{eq})\\), air \\((T_{air})\\), and Maa microperforates \\((T_{maa})\\) in acoustipy.</p> <p>The transfer matrices are also defined under 2 different sound field conditions -- normal and diffuse incidence.</p>"},{"location":"Theory/TMM_Theory/#normal-incidence-matrices","title":"Normal Incidence Matrices","text":"\\[ T_{eq} =  \\begin{bmatrix} \\cos (k_{c}t) &amp; jZ_{c}\\sin(k_{c}t) \\\\ \\frac{j}{Z_{c}}\\sin(k_{c}t) &amp; \\cos (k_{c}t) \\\\ \\end{bmatrix} \\] \\[ T_{air} =  \\begin{bmatrix} \\cos (k_{0}t) &amp; jZ_{0}\\sin(k_{0}t) \\\\ \\frac{j}{Z_{0}}\\sin(k_{0}t) &amp; \\cos (k_{0}t) \\\\ \\end{bmatrix} \\] \\[ T_{maa} =  \\begin{bmatrix} 1 &amp; Z_{c}\\\\ 0 &amp; 1 \\\\ \\end{bmatrix} \\] <p>where \\(Z_{c}\\) and \\(k_{c}\\) are the characteristic impedence and wavenumber of the material calculated by the ADD_XXX_Layer methods implemented in acoustipy. \\(Z_{0}\\) and \\(k_{0}\\) are the characteristic impedence and wavenumber of air and are determined via:</p> \\[ Z_{0} = \\rho_{0} c_{0} \\] \\[ k_{0} = \\frac{\\omega}{c_{0}}     \\] <p>where \\(\\rho_{0}\\) is the density of air, \\(\\omega\\) is the angular frequency, and \\(c_{0}\\) is the speed of sound in air.</p>"},{"location":"Theory/TMM_Theory/#diffuse-incidence-matrices","title":"Diffuse Incidence Matrices","text":"\\[ T_{eq} =  \\begin{bmatrix} \\cos (k_{x}t) &amp; j\\frac{Z_{c} k_{c}}{k_{x}}\\sin(k_{x}t) \\\\ j \\frac{j k_{x}}{Z_{c} k_{c}}\\sin(k_{x}t) &amp; \\cos (k_{x}t) \\\\ \\end{bmatrix} \\] \\[ T_{air} =  \\begin{bmatrix} \\cos (k_{x}t) &amp; j\\frac{Z_{c} k_{0}}{k_{x}}\\sin(k_{x}t) \\\\ j \\frac{k_{x}}{Z_{c} k_{0}}\\sin(k_{x}t) &amp; \\cos (k_{x}t) \\\\ \\end{bmatrix} \\] \\[ T_{maa} =  \\begin{bmatrix} 1 &amp; Z_{c}\\cos(\\theta)\\\\ 0 &amp; 1 \\\\ \\end{bmatrix} \\] <p>where \\(k_{x}\\) is:</p> \\[ k_{x} = \\sqrt{k_{c}-k_{0}\\sin(\\theta)}    \\] <p>and \\(\\theta\\) is the angle of incidence.</p> <p>To obtain the total transfer matrix \\((T_{t})\\) of a multilayered structure, matrix multiplication is performed using the individual transfer matrices -- starting with the layer closest to the incident sound.</p> <p>The illustration below is an example of a resistive screen on the face of a porous material, backed by a layer of air.</p> <p></p> <p>This is represented by:</p> \\[ T_{t} = T_{screen} \\times T_{porous} \\times T_{air}     \\]"},{"location":"Theory/TMM_Theory_General/","title":"Overview","text":""},{"location":"Theory/TMM_Theory_General/#all-models-and-methods-described-in-the-theory-section-align-with-the-code-implementation","title":"All models and methods described in the Theory section align with the code implementation.","text":""},{"location":"Theory/TMM_Theory_General/#for-each-material-model-an-array-of-values-corresponding-to-the-complex-characteristic-impedance-z_c-and-wavenumber-k_c-are-generated-and-used-to-calculate-that-layers-transfer-matrix","title":"For each material model, an array of values corresponding to the complex characteristic impedance \\((Z_{c})\\) and wavenumber \\((k_{c})\\) are generated and used to calculate that layer's transfer matrix.","text":""},{"location":"Theory/Transmission_Theory/","title":"Transmission Loss","text":"<p>The frequency-dependent transmission coefficients \\((\\tau)\\) are calculated directly from the total transfer matrix \\((T_{t})\\) of a multilayered structure.  These coefficients are a measure of how much sound passes through a structure.</p> <p>The coefficients can be calculated under both normal and diffuse sound field conditions.  Under a normal incidence sound field, the sound impinges on the surface from a single, perpendicular angle.  In the diffuse field case, the incident sound theoretically strikes the surface of the material from all possible angles -- though the acoustipy implementation defaults to angles between 0 and 79, as seen in literature on the topic.</p> <p>The transmission coefficients can then be used to calculate transmission loss \\((TL)\\), which is also a frequency dependent metric.</p> <p>The acoustipy implementation for both cases can be found here.</p>"},{"location":"Theory/Transmission_Theory/#normal-incidence","title":"Normal Incidence","text":"<p>Starting from the total transfer matrix:</p> \\[ T_{t} =  \\begin{bmatrix} T_{11} &amp; T_{12}\\\\ T_{21} &amp; T_{22} \\\\ \\end{bmatrix} \\] <p>Then, the transmission coefficients \\((\\tau)\\) are:</p> \\[ \\tau = \\frac{2e^{jk_{0}t}}{T_{11}+\\frac{T_{12}}{Z_{0}}+Z_{0}T_{21}+T_{22}}   \\] <p>where \\(t\\) is the total thickness of the structure and \\(k_{0}\\) is the wavenumber:</p> \\[ k_{0} = \\frac{\\omega}{c_{0}} \\] <p>where \\(\\omega\\) is the angular frequency and \\(c_{0}\\) is the speed of sound in air.</p> <p>and where \\(Z_{0}\\) is the characteristic impedence of air:</p> \\[ Z_{0} = \\rho_{0} c_{0} \\] <p>and \\(\\rho_{0}\\) is the density of air.</p> <p>Then the transmission loss is:</p> \\[ TL = 10\\log_{10}\\frac{1}{|\\tau|^2} \\]"},{"location":"Theory/Transmission_Theory/#diffuse-incidence","title":"Diffuse Incidence","text":"<p>Under the diffuse sound field condition, the calculation of the transmission coefficients is:</p> \\[ \\tau = \\frac{2e^{jk_{0}t}}{T_{11}+\\frac{T_{12}\\cos\\theta}{Z_{0}}+\\frac{Z_{0}T_{21}}{\\cos\\theta}+T_{22}}   \\] <p>which yields a vector of shape \\([f, \\theta]\\).  To collapse this vector to shape \\([f,1]\\), Paris' formula is used as shown below.</p> \\[ T = \\frac{\\sum \\tau\\cos(\\theta)\\sin(\\theta)}{\\sum \\cos(\\theta)\\sin(\\theta)} \\] <p>the transmission loss is then calculated in the same manner as the normal incidence condition:</p> \\[ TL = 10\\log_{10}\\frac{1}{|T|^2} \\]"}]}